<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta::Array&lt; DataT, ArrayT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classsparta_1_1Array.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsparta_1_1Array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sparta::Array&lt; DataT, ArrayT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> is essentially a fixed size vector, maintains a concept of validity of its indexes, and provides access via stl iteration and general get methods.  
 <a href="classsparta_1_1Array.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Array_8hpp_source.html">Array.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsparta_1_1Array_1_1ArrayIterator.html">ArrayIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator struct for this array.  <a href="structsparta_1_1Array_1_1ArrayIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aba2f9a116f39480d9ffd032f94910e05"><td class="memItemLeft" align="right" valign="top"><a id="aba2f9a116f39480d9ffd032f94910e05"></a>
typedef DataT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#aba2f9a116f39480d9ffd032f94910e05">value_type</a></td></tr>
<tr class="memdesc:aba2f9a116f39480d9ffd032f94910e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data type, STL style. <br /></td></tr>
<tr class="separator:aba2f9a116f39480d9ffd032f94910e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc580ba5d10ff0a4d8e20c52159b1f4"><td class="memItemLeft" align="right" valign="top"><a id="a7cc580ba5d10ff0a4d8e20c52159b1f4"></a>
typedef DataT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a7cc580ba5d10ff0a4d8e20c52159b1f4">DataType</a></td></tr>
<tr class="memdesc:a7cc580ba5d10ff0a4d8e20c52159b1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected typedef for the data that will be stored in this structure. <br /></td></tr>
<tr class="separator:a7cc580ba5d10ff0a4d8e20c52159b1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9422bc0b9f7088e4a34e505d36f51309"><td class="memItemLeft" align="right" valign="top"><a id="a9422bc0b9f7088e4a34e505d36f51309"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a9422bc0b9f7088e4a34e505d36f51309">size_type</a></td></tr>
<tr class="memdesc:a9422bc0b9f7088e4a34e505d36f51309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for size_type. <br /></td></tr>
<tr class="separator:a9422bc0b9f7088e4a34e505d36f51309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9173c96bed12171030a5ddd41e38a018"><td class="memItemLeft" align="right" valign="top"><a id="a9173c96bed12171030a5ddd41e38a018"></a>
typedef std::list&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a9173c96bed12171030a5ddd41e38a018">AgedList</a></td></tr>
<tr class="memdesc:a9173c96bed12171030a5ddd41e38a018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a list of indexes in age order. <br /></td></tr>
<tr class="separator:a9173c96bed12171030a5ddd41e38a018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9401f50e670b30df374e940e8eb47be5"><td class="memItemLeft" align="right" valign="top"><a id="a9401f50e670b30df374e940e8eb47be5"></a>
typedef <a class="el" href="structsparta_1_1Array_1_1ArrayIterator.html">ArrayIterator</a>&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a></td></tr>
<tr class="memdesc:a9401f50e670b30df374e940e8eb47be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for regular iterator. <br /></td></tr>
<tr class="separator:a9401f50e670b30df374e940e8eb47be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3372f9a508acd1312eecff8efce01022"><td class="memItemLeft" align="right" valign="top"><a id="a3372f9a508acd1312eecff8efce01022"></a>
typedef <a class="el" href="structsparta_1_1Array_1_1ArrayIterator.html">ArrayIterator</a>&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a3372f9a508acd1312eecff8efce01022">const_iterator</a></td></tr>
<tr class="memdesc:a3372f9a508acd1312eecff8efce01022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for constant iterator. <br /></td></tr>
<tr class="separator:a3372f9a508acd1312eecff8efce01022"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc3b48ca8f281222590b94db05ff0116"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#acc3b48ca8f281222590b94db05ff0116">getCircularIterator</a> (uint32_t idx=0)</td></tr>
<tr class="memdesc:acc3b48ca8f281222590b94db05ff0116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator that is circular on the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> (has no <a class="el" href="classsparta_1_1Array.html#a109717b550dd8e2e6556f624511934b8" title="STL-like end operation.">end()</a>)  <a href="classsparta_1_1Array.html#acc3b48ca8f281222590b94db05ff0116">More...</a><br /></td></tr>
<tr class="separator:acc3b48ca8f281222590b94db05ff0116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab94d543d1def48f666f176e364b5a1f"><td class="memItemLeft" align="right" valign="top"><a id="aab94d543d1def48f666f176e364b5a1f"></a>
<a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#aab94d543d1def48f666f176e364b5a1f">getUnitializedIterator</a> ()</td></tr>
<tr class="memdesc:aab94d543d1def48f666f176e364b5a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a method to get an uninitialized iterator. <br /></td></tr>
<tr class="separator:aab94d543d1def48f666f176e364b5a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907a7790d84849692fd3b90bf4f41a59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a907a7790d84849692fd3b90bf4f41a59">begin</a> ()</td></tr>
<tr class="memdesc:a907a7790d84849692fd3b90bf4f41a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like begin operation, starts at index 0 (ignores valid bit).  <a href="classsparta_1_1Array.html#a907a7790d84849692fd3b90bf4f41a59">More...</a><br /></td></tr>
<tr class="separator:a907a7790d84849692fd3b90bf4f41a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14979dea733c40c2233453652d1dd77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Array.html#a3372f9a508acd1312eecff8efce01022">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#ac14979dea733c40c2233453652d1dd77">begin</a> () const</td></tr>
<tr class="memdesc:ac14979dea733c40c2233453652d1dd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like begin operation, const, starts at index 0 (ignores valid bit).  <a href="classsparta_1_1Array.html#ac14979dea733c40c2233453652d1dd77">More...</a><br /></td></tr>
<tr class="separator:ac14979dea733c40c2233453652d1dd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109717b550dd8e2e6556f624511934b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a109717b550dd8e2e6556f624511934b8">end</a> ()</td></tr>
<tr class="memdesc:a109717b550dd8e2e6556f624511934b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like end operation.  <a href="classsparta_1_1Array.html#a109717b550dd8e2e6556f624511934b8">More...</a><br /></td></tr>
<tr class="separator:a109717b550dd8e2e6556f624511934b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46951fc8d770a8d48c961fba80d376c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Array.html#a3372f9a508acd1312eecff8efce01022">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#ae46951fc8d770a8d48c961fba80d376c">end</a> () const</td></tr>
<tr class="memdesc:ae46951fc8d770a8d48c961fba80d376c"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like end operation, const.  <a href="classsparta_1_1Array.html#ae46951fc8d770a8d48c961fba80d376c">More...</a><br /></td></tr>
<tr class="separator:ae46951fc8d770a8d48c961fba80d376c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1ec52fc43356ee602b064087efa012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a1b1ec52fc43356ee602b064087efa012">abegin</a> ()</td></tr>
<tr class="memdesc:a1b1ec52fc43356ee602b064087efa012"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like begin operation, starts at the oldest valid index.  <a href="classsparta_1_1Array.html#a1b1ec52fc43356ee602b064087efa012">More...</a><br /></td></tr>
<tr class="separator:a1b1ec52fc43356ee602b064087efa012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbe7b4bc9837392562aecc1bedf0a54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Array.html#a3372f9a508acd1312eecff8efce01022">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a8cbe7b4bc9837392562aecc1bedf0a54">abegin</a> () const</td></tr>
<tr class="memdesc:a8cbe7b4bc9837392562aecc1bedf0a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like begin operation, const, starts at the oldest valid index.  <a href="classsparta_1_1Array.html#a8cbe7b4bc9837392562aecc1bedf0a54">More...</a><br /></td></tr>
<tr class="separator:a8cbe7b4bc9837392562aecc1bedf0a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed7f95597f8b7488b2607eb5b686cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a6ed7f95597f8b7488b2607eb5b686cdd">aend</a> ()</td></tr>
<tr class="memdesc:a6ed7f95597f8b7488b2607eb5b686cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like end operation.  <a href="classsparta_1_1Array.html#a6ed7f95597f8b7488b2607eb5b686cdd">More...</a><br /></td></tr>
<tr class="separator:a6ed7f95597f8b7488b2607eb5b686cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7500ddfee429ad4c31e8b97d76c6b14a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Array.html#a3372f9a508acd1312eecff8efce01022">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a7500ddfee429ad4c31e8b97d76c6b14a">aend</a> () const</td></tr>
<tr class="memdesc:a7500ddfee429ad4c31e8b97d76c6b14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like end operation, const.  <a href="classsparta_1_1Array.html#a7500ddfee429ad4c31e8b97d76c6b14a">More...</a><br /></td></tr>
<tr class="separator:a7500ddfee429ad4c31e8b97d76c6b14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539dcd630e9aae1d235b5ff14e995387"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a539dcd630e9aae1d235b5ff14e995387">Array</a> (const std::string &amp;name, uint32_t num_entries, const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *clk, <a class="el" href="classsparta_1_1StatisticSet.html">StatisticSet</a> *statset=nullptr, <a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a> stat_vis_general=<a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a>, <a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a> stat_vis_detailed=<a class="el" href="classsparta_1_1InstrumentationNode.html#a855b6ecdd93e412052ae264032002ce1a01a69b1a50e88559f40efc68ba7e5224">InstrumentationNode::VIS_HIDDEN</a>, <a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a> stat_vis_max=<a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a>, <a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a> stat_vis_avg=<a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a>)</td></tr>
<tr class="memdesc:a539dcd630e9aae1d235b5ff14e995387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array.  <a href="classsparta_1_1Array.html#a539dcd630e9aae1d235b5ff14e995387">More...</a><br /></td></tr>
<tr class="separator:a539dcd630e9aae1d235b5ff14e995387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90601a0bc2ddfaa11d58903b7c8e774"><td class="memItemLeft" align="right" valign="top"><a id="ad90601a0bc2ddfaa11d58903b7c8e774"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#ad90601a0bc2ddfaa11d58903b7c8e774">~Array</a> ()</td></tr>
<tr class="memdesc:ad90601a0bc2ddfaa11d58903b7c8e774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:ad90601a0bc2ddfaa11d58903b7c8e774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b47047a46bca0f7375c680465fd2192"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a6b47047a46bca0f7375c680465fd2192">isValid</a> (const uint32_t idx) const</td></tr>
<tr class="memdesc:a6b47047a46bca0f7375c680465fd2192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether an index is currently valid.  <a href="classsparta_1_1Array.html#a6b47047a46bca0f7375c680465fd2192">More...</a><br /></td></tr>
<tr class="separator:a6b47047a46bca0f7375c680465fd2192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1608f65c92f7f8463946cf1ffb02b7d8"><td class="memItemLeft" align="right" valign="top">const DataT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a1608f65c92f7f8463946cf1ffb02b7d8">read</a> (const uint32_t idx) const</td></tr>
<tr class="memdesc:a1608f65c92f7f8463946cf1ffb02b7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read (only) the data at an index.  <a href="classsparta_1_1Array.html#a1608f65c92f7f8463946cf1ffb02b7d8">More...</a><br /></td></tr>
<tr class="separator:a1608f65c92f7f8463946cf1ffb02b7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a09d404a7f1b684c256f372737b28b0"><td class="memItemLeft" align="right" valign="top">DataT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a0a09d404a7f1b684c256f372737b28b0">access</a> (const uint32_t idx)</td></tr>
<tr class="memdesc:a0a09d404a7f1b684c256f372737b28b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access (writeable) the data at a position.  <a href="classsparta_1_1Array.html#a0a09d404a7f1b684c256f372737b28b0">More...</a><br /></td></tr>
<tr class="separator:a0a09d404a7f1b684c256f372737b28b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef7ce44f6458ea2061d9776678178dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Array.html#a3372f9a508acd1312eecff8efce01022">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a6ef7ce44f6458ea2061d9776678178dc">getOldestIndex</a> (const uint32_t nth=0) const</td></tr>
<tr class="memdesc:a6ef7ce44f6458ea2061d9776678178dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the oldest index in the array.  <a href="classsparta_1_1Array.html#a6ef7ce44f6458ea2061d9776678178dc">More...</a><br /></td></tr>
<tr class="separator:a6ef7ce44f6458ea2061d9776678178dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bf00d9c60726b2939338c0c885094e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Array.html#a3372f9a508acd1312eecff8efce01022">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a63bf00d9c60726b2939338c0c885094e">getYoungestIndex</a> (const uint32_t nth=0) const</td></tr>
<tr class="memdesc:a63bf00d9c60726b2939338c0c885094e"><td class="mdescLeft">&#160;</td><td class="mdescRight">provide access the youngest index in the array.  <a href="classsparta_1_1Array.html#a63bf00d9c60726b2939338c0c885094e">More...</a><br /></td></tr>
<tr class="separator:a63bf00d9c60726b2939338c0c885094e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b458c2ca7766f2f6414241bcf4505fe"><td class="memItemLeft" align="right" valign="top"><a id="a2b458c2ca7766f2f6414241bcf4505fe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a2b458c2ca7766f2f6414241bcf4505fe">getNextOldestIndex</a> (uint32_t &amp;prev_idx) const</td></tr>
<tr class="memdesc:a2b458c2ca7766f2f6414241bcf4505fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input argument to the index containing the location of the next oldest item after input argument. If the input argument is the youngest index, we return false. <br /></td></tr>
<tr class="separator:a2b458c2ca7766f2f6414241bcf4505fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8594937b9581efbf84ecaf76ed5a35"><td class="memItemLeft" align="right" valign="top"><a id="a5d8594937b9581efbf84ecaf76ed5a35"></a>
const <a class="el" href="classsparta_1_1Array.html#a9173c96bed12171030a5ddd41e38a018">AgedList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a5d8594937b9581efbf84ecaf76ed5a35">getAgedList</a> () const</td></tr>
<tr class="memdesc:a5d8594937b9581efbf84ecaf76ed5a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide access to our aged_list_ internals. <br /></td></tr>
<tr class="separator:a5d8594937b9581efbf84ecaf76ed5a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bb4a1d42dec14d026afe15c65eef35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Array.html#a9422bc0b9f7088e4a34e505d36f51309">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a04bb4a1d42dec14d026afe15c65eef35">capacity</a> () const</td></tr>
<tr class="memdesc:a04bb4a1d42dec14d026afe15c65eef35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of elements this <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> can hold.  <a href="classsparta_1_1Array.html#a04bb4a1d42dec14d026afe15c65eef35">More...</a><br /></td></tr>
<tr class="separator:a04bb4a1d42dec14d026afe15c65eef35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58ce73335e9712a099f78571664fb22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Array.html#a9422bc0b9f7088e4a34e505d36f51309">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#ad58ce73335e9712a099f78571664fb22">numValid</a> () const</td></tr>
<tr class="memdesc:ad58ce73335e9712a099f78571664fb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of valid entries contained.  <a href="classsparta_1_1Array.html#ad58ce73335e9712a099f78571664fb22">More...</a><br /></td></tr>
<tr class="separator:ad58ce73335e9712a099f78571664fb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039224bc8e092407594aff700851e8b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Array.html#a9422bc0b9f7088e4a34e505d36f51309">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a039224bc8e092407594aff700851e8b4">size</a> () const</td></tr>
<tr class="separator:a039224bc8e092407594aff700851e8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e5a2ba4cb4744cffa13dd76745e138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Array.html#a9422bc0b9f7088e4a34e505d36f51309">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a48e5a2ba4cb4744cffa13dd76745e138">numFree</a> () const</td></tr>
<tr class="memdesc:a48e5a2ba4cb4744cffa13dd76745e138"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of free entries.  <a href="classsparta_1_1Array.html#a48e5a2ba4cb4744cffa13dd76745e138">More...</a><br /></td></tr>
<tr class="separator:a48e5a2ba4cb4744cffa13dd76745e138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb0ab0790272625843677fc769654ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#aedb0ab0790272625843677fc769654ff">erase</a> (const <a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a> &amp;iter)</td></tr>
<tr class="memdesc:aedb0ab0790272625843677fc769654ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate data at an iterator position.  <a href="classsparta_1_1Array.html#aedb0ab0790272625843677fc769654ff">More...</a><br /></td></tr>
<tr class="separator:aedb0ab0790272625843677fc769654ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bc7a8692af50863c6bbb276a2609d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a02bc7a8692af50863c6bbb276a2609d6">erase</a> (const uint32_t &amp;idx)</td></tr>
<tr class="memdesc:a02bc7a8692af50863c6bbb276a2609d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate the entry at a certain index.  <a href="classsparta_1_1Array.html#a02bc7a8692af50863c6bbb276a2609d6">More...</a><br /></td></tr>
<tr class="separator:a02bc7a8692af50863c6bbb276a2609d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0797e3e64c1819e7ef7c48d665f8f8"><td class="memItemLeft" align="right" valign="top"><a id="aef0797e3e64c1819e7ef7c48d665f8f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#aef0797e3e64c1819e7ef7c48d665f8f8">clear</a> ()</td></tr>
<tr class="memdesc:aef0797e3e64c1819e7ef7c48d665f8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the array of all data. <br /></td></tr>
<tr class="separator:aef0797e3e64c1819e7ef7c48d665f8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469f43e31ed089cede106dd07254ffa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a469f43e31ed089cede106dd07254ffa9">write</a> (const uint32_t idx, const DataT &amp;dat)</td></tr>
<tr class="memdesc:a469f43e31ed089cede106dd07254ffa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the array.  <a href="classsparta_1_1Array.html#a469f43e31ed089cede106dd07254ffa9">More...</a><br /></td></tr>
<tr class="separator:a469f43e31ed089cede106dd07254ffa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1b7e23f0d8cb0a251652942448106f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#afe1b7e23f0d8cb0a251652942448106f">write</a> (const uint32_t idx, DataT &amp;&amp;dat)</td></tr>
<tr class="memdesc:afe1b7e23f0d8cb0a251652942448106f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the array.  <a href="classsparta_1_1Array.html#afe1b7e23f0d8cb0a251652942448106f">More...</a><br /></td></tr>
<tr class="separator:afe1b7e23f0d8cb0a251652942448106f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0831489c25514d68eb4be986ae6b2f3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a0831489c25514d68eb4be986ae6b2f3b">write</a> (const <a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a> &amp;iter, const DataT &amp;dat)</td></tr>
<tr class="memdesc:a0831489c25514d68eb4be986ae6b2f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data at an iterator position.  <a href="classsparta_1_1Array.html#a0831489c25514d68eb4be986ae6b2f3b">More...</a><br /></td></tr>
<tr class="separator:a0831489c25514d68eb4be986ae6b2f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7bcdfa954a2c815a31ec40469e570b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#a9b7bcdfa954a2c815a31ec40469e570b">write</a> (const <a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a> &amp;iter, DataT &amp;&amp;dat)</td></tr>
<tr class="memdesc:a9b7bcdfa954a2c815a31ec40469e570b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data at an iterator position.  <a href="classsparta_1_1Array.html#a9b7bcdfa954a2c815a31ec40469e570b">More...</a><br /></td></tr>
<tr class="separator:a9b7bcdfa954a2c815a31ec40469e570b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7be5afcb2c23c312f3420639bf9ff28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#ab7be5afcb2c23c312f3420639bf9ff28">isYounger</a> (uint32_t lhs, uint32_t rhs)</td></tr>
<tr class="memdesc:ab7be5afcb2c23c312f3420639bf9ff28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an index was written (using <a class="el" href="classsparta_1_1Array.html#a469f43e31ed089cede106dd07254ffa9" title="Write data to the array.">write()</a>) to the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> after another index.  <a href="classsparta_1_1Array.html#ab7be5afcb2c23c312f3420639bf9ff28">More...</a><br /></td></tr>
<tr class="separator:ab7be5afcb2c23c312f3420639bf9ff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fae013527896550d8a4ae1b1d621c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#ad2fae013527896550d8a4ae1b1d621c1">isOlder</a> (uint32_t lhs, uint32_t rhs)</td></tr>
<tr class="memdesc:ad2fae013527896550d8a4ae1b1d621c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an index was written (using <a class="el" href="classsparta_1_1Array.html#a469f43e31ed089cede106dd07254ffa9" title="Write data to the array.">write()</a>) to the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> before another index.  <a href="classsparta_1_1Array.html#ad2fae013527896550d8a4ae1b1d621c1">More...</a><br /></td></tr>
<tr class="separator:ad2fae013527896550d8a4ae1b1d621c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa046c91cf846523a2c1fba7765246ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html#aaa046c91cf846523a2c1fba7765246ca">enableCollection</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent)</td></tr>
<tr class="memdesc:aaa046c91cf846523a2c1fba7765246ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a auto-collector for this <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a>.  <a href="classsparta_1_1Array.html#aaa046c91cf846523a2c1fba7765246ca">More...</a><br /></td></tr>
<tr class="separator:aaa046c91cf846523a2c1fba7765246ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class DataT, ArrayType ArrayT = ArrayType::AGED&gt;<br />
class sparta::Array&lt; DataT, ArrayT &gt;</h3>

<p><a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> is essentially a fixed size vector, maintains a concept of validity of its indexes, and provides access via stl iteration and general get methods. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataT</td><td>the data type stored in the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a>. </td></tr>
    <tr><td class="paramname">ArrayT</td><td>the type of array <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3a1e23852820b9154316c7c06e2b7ba051">ArrayType::AGED</a> vs ArrayType::NORMAL</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> class maintains a list of elements, constrained to the number of entries, allowing a user to add/remove entries from the middle, beginning, or end without collapsing. If the template parameter <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3a1e23852820b9154316c7c06e2b7ba051">ArrayType::AGED</a> is provided (default), the array will keep track of the age of the internal components.</p>
<p>The methods <a class="el" href="classsparta_1_1Array.html#a907a7790d84849692fd3b90bf4f41a59" title="STL-like begin operation, starts at index 0 (ignores valid bit).">begin()</a> and <a class="el" href="classsparta_1_1Array.html#a109717b550dd8e2e6556f624511934b8" title="STL-like end operation.">end()</a> will return iterators to the array, with <a class="el" href="classsparta_1_1Array.html#a907a7790d84849692fd3b90bf4f41a59" title="STL-like begin operation, starts at index 0 (ignores valid bit).">begin()</a> always returning an iterator pointing to index 0 and <a class="el" href="classsparta_1_1Array.html#a109717b550dd8e2e6556f624511934b8" title="STL-like end operation.">end()</a> pointing beyond it. The iterator <b>might</b> <b>not</b> be pointing to valid data, so a call to <a class="el" href="classsparta_1_1Array.html#a6b47047a46bca0f7375c680465fd2192" title="Determine whether an index is currently valid.">isValid()</a> on the iterator is required before dereferencing.</p>
<p>To iterator over the aged list, use the methods <a class="el" href="classsparta_1_1Array.html#a1b1ec52fc43356ee602b064087efa012" title="STL-like begin operation, starts at the oldest valid index.">abegin()</a> and <a class="el" href="classsparta_1_1Array.html#a6ed7f95597f8b7488b2607eb5b686cdd" title="STL-like end operation.">aend()</a>. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00055">55</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a539dcd630e9aae1d235b5ff14e995387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539dcd630e9aae1d235b5ff14e995387">&#9670;&nbsp;</a></span>Array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::<a class="el" href="classsparta_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *&#160;</td>
          <td class="paramname"><em>clk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1StatisticSet.html">StatisticSet</a> *&#160;</td>
          <td class="paramname"><em>statset</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a>&#160;</td>
          <td class="paramname"><em>stat_vis_general</em> = <code><a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a>&#160;</td>
          <td class="paramname"><em>stat_vis_detailed</em> = <code><a class="el" href="classsparta_1_1InstrumentationNode.html#a855b6ecdd93e412052ae264032002ce1a01a69b1a50e88559f40efc68ba7e5224">InstrumentationNode::VIS_HIDDEN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a>&#160;</td>
          <td class="paramname"><em>stat_vis_max</em> = <code><a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a>&#160;</td>
          <td class="paramname"><em>stat_vis_avg</em> = <code><a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the buffer </td></tr>
    <tr><td class="paramname">num_entries</td><td>The number of entries this buffer can hold </td></tr>
    <tr><td class="paramname">clk</td><td>The clock this buffer belongs to </td></tr>
    <tr><td class="paramname">statset</td><td>Pointer to the counter set to register utilization counts; default nullptr. This works for timed and untimed.</td></tr>
    <tr><td class="paramname">stat_vis_general</td><td>Sets the visibility of the stat counters for the 0th and last index of the utilization counts, so the empty and full counts.</td></tr>
    <tr><td class="paramname">stat_vis_detailed</td><td>Sets the visibility of the stat counts between 0 and the last index. i.e. more detailed than the general stats, default VIS_HIDDEN</td></tr>
    <tr><td class="paramname">stat_vis_max</td><td>Sets the visibility for a stat that contains the maximum utilization for this buffer. The default is AUTO_VISIBILITY.</td></tr>
    <tr><td class="paramname">stat_vis_avg</td><td>Sets the visibility for a stat that contains the weighted utilization average for this buffer. The default is AUTO_VISIBILITY.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>By default the stat_vis_* options are set to VIS_SPARTA_DEFAULT, for this structure AUTO_VISIBILITY resolves to CONTAINER_DEFAULT_VISIBILITY which at the time of writing this comment is set to VIS_HIDDEN. If you rely on the stats from this container you should explicitly set the visibility. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00936">936</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b1ec52fc43356ee602b064087efa012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1ec52fc43356ee602b064087efa012">&#9670;&nbsp;</a></span>abegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::abegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like begin operation, starts at the oldest valid index. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the oldest entry in the array </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00422">422</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a8cbe7b4bc9837392562aecc1bedf0a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbe7b4bc9837392562aecc1bedf0a54">&#9670;&nbsp;</a></span>abegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html#a3372f9a508acd1312eecff8efce01022">const_iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::abegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like begin operation, const, starts at the oldest valid index. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the oldest entry in the array </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00435">435</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a0a09d404a7f1b684c256f372737b28b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a09d404a7f1b684c256f372737b28b0">&#9670;&nbsp;</a></span>access()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataT&amp; <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::access </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access (writeable) the data at a position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to access. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00534">534</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a6ed7f95597f8b7488b2607eb5b686cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed7f95597f8b7488b2607eb5b686cdd">&#9670;&nbsp;</a></span>aend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::aend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like end operation. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element past the youngest entry </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00447">447</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a7500ddfee429ad4c31e8b97d76c6b14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7500ddfee429ad4c31e8b97d76c6b14a">&#9670;&nbsp;</a></span>aend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html#a3372f9a508acd1312eecff8efce01022">const_iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::aend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like end operation, const. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element one past the youngest entry </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00456">456</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a907a7790d84849692fd3b90bf4f41a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907a7790d84849692fd3b90bf4f41a59">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like begin operation, starts at index 0 (ignores valid bit). </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the beginning of the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00386">386</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="ac14979dea733c40c2233453652d1dd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14979dea733c40c2233453652d1dd77">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html#a3372f9a508acd1312eecff8efce01022">const_iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like begin operation, const, starts at index 0 (ignores valid bit). </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the beginning of the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00395">395</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a04bb4a1d42dec14d026afe15c65eef35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bb4a1d42dec14d026afe15c65eef35">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html#a9422bc0b9f7088e4a34e505d36f51309">size_type</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum number of elements this <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> can hold. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of positions this array was constructed with </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00643">643</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="aaa046c91cf846523a2c1fba7765246ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa046c91cf846523a2c1fba7765246ca">&#9670;&nbsp;</a></span>enableCollection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::enableCollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up a auto-collector for this <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent tree node under which to create the collection </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00802">802</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a109717b550dd8e2e6556f624511934b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109717b550dd8e2e6556f624511934b8">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like end operation. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the end of the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a>, past the last element </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00404">404</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="ae46951fc8d770a8d48c961fba80d376c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46951fc8d770a8d48c961fba80d376c">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html#a3372f9a508acd1312eecff8efce01022">const_iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like end operation, const. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the end of the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a>, past the last element </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00413">413</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="aedb0ab0790272625843677fc769654ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb0ab0790272625843677fc769654ff">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidate data at an iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>An iterator used to invalidate &ndash; must be valid </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00673">673</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a02bc7a8692af50863c6bbb276a2609d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02bc7a8692af50863c6bbb276a2609d6">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidate the entry at a certain index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to invalidate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00682">682</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="acc3b48ca8f281222590b94db05ff0116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3b48ca8f281222590b94db05ff0116">&#9670;&nbsp;</a></span>getCircularIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::getCircularIterator </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator that is circular on the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> (has no <a class="el" href="classsparta_1_1Array.html#a109717b550dd8e2e6556f624511934b8" title="STL-like end operation.">end()</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Where to start from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator type that a ++ will never == <a class="el" href="classsparta_1_1Array.html#a109717b550dd8e2e6556f624511934b8" title="STL-like end operation.">end()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00367">367</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a6ef7ce44f6458ea2061d9776678178dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef7ce44f6458ea2061d9776678178dc">&#9670;&nbsp;</a></span>getOldestIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html#a3372f9a508acd1312eecff8efce01022">const_iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::getOldestIndex </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>nth</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the oldest index in the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nth</td><td>Is the nth oldest entry you are looking for. nth=0 is the oldest entry, nth = 1 is the second oldest, etc.. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the nth oldest entry. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this method may be expensive for larger nth values. Low values should be very quick.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is only accessible if the template parameter FullArrayType == AGED </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00552">552</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a63bf00d9c60726b2939338c0c885094e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bf00d9c60726b2939338c0c885094e">&#9670;&nbsp;</a></span>getYoungestIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html#a3372f9a508acd1312eecff8efce01022">const_iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::getYoungestIndex </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>nth</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>provide access the youngest index in the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nth</td><td>Is the nth youngest entry to be found. nth=0 is the youngest, nth=1 is the second youngest, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the nth youngest index. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this method may get expensive for larger nth values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is only accessible if the template parameter FullArrayType == AGED. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00590">590</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="ad2fae013527896550d8a4ae1b1d621c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fae013527896550d8a4ae1b1d621c1">&#9670;&nbsp;</a></span>isOlder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::isOlder </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if an index was written (using <a class="el" href="classsparta_1_1Array.html#a469f43e31ed089cede106dd07254ffa9" title="Write data to the array.">write()</a>) to the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> before another index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an index to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>an index to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if lhs was written at less recently than rhs was written at. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00790">790</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a6b47047a46bca0f7375c680465fd2192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b47047a46bca0f7375c680465fd2192">&#9670;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::isValid </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether an index is currently valid. </p>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00515">515</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="ab7be5afcb2c23c312f3420639bf9ff28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7be5afcb2c23c312f3420639bf9ff28">&#9670;&nbsp;</a></span>isYounger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::isYounger </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if an index was written (using <a class="el" href="classsparta_1_1Array.html#a469f43e31ed089cede106dd07254ffa9" title="Write data to the array.">write()</a>) to the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> after another index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an index to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>an index to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if lhs was written more recently than rhs to the array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00775">775</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a48e5a2ba4cb4744cffa13dd76745e138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e5a2ba4cb4744cffa13dd76745e138">&#9670;&nbsp;</a></span>numFree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html#a9422bc0b9f7088e4a34e505d36f51309">size_type</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::numFree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of free entries. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of free spaces in the array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00664">664</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="ad58ce73335e9712a099f78571664fb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58ce73335e9712a099f78571664fb22">&#9670;&nbsp;</a></span>numValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html#a9422bc0b9f7088e4a34e505d36f51309">size_type</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::numValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of valid entries contained. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of valid elements in the array </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00651">651</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a1608f65c92f7f8463946cf1ffb02b7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1608f65c92f7f8463946cf1ffb02b7d8">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DataT&amp; <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::read </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read (only) the data at an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the index to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00524">524</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a039224bc8e092407594aff700851e8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039224bc8e092407594aff700851e8b4">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html#a9422bc0b9f7088e4a34e505d36f51309">size_type</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classsparta_1_1Array.html#ad58ce73335e9712a099f78571664fb22" title="The number of valid entries contained.">numValid()</a> &ndash; function for stl compatibility. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00656">656</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a0831489c25514d68eb4be986ae6b2f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0831489c25514d68eb4be986ae6b2f3b">&#9670;&nbsp;</a></span>write() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataT &amp;&#160;</td>
          <td class="paramname"><em>dat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data at an iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator pointing to the data </td></tr>
    <tr><td class="paramname">dat</td><td>The data to write at the iterator location</td></tr>
  </table>
  </dd>
</dl>
<p>This will write to the location at <em>iter</em>, whether the iterator is valid or not. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00750">750</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a9b7bcdfa954a2c815a31ec40469e570b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7bcdfa954a2c815a31ec40469e570b">&#9670;&nbsp;</a></span>write() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Array.html#a9401f50e670b30df374e940e8eb47be5">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataT &amp;&amp;&#160;</td>
          <td class="paramname"><em>dat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data at an iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator pointing to the data </td></tr>
    <tr><td class="paramname">dat</td><td>The data to write at the iterator location</td></tr>
  </table>
  </dd>
</dl>
<p>This will write to the location at <em>iter</em>, whether the iterator is valid or not. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00763">763</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a469f43e31ed089cede106dd07254ffa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469f43e31ed089cede106dd07254ffa9">&#9670;&nbsp;</a></span>write() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataT &amp;&#160;</td>
          <td class="paramname"><em>dat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to write at </td></tr>
    <tr><td class="paramname">dat</td><td>The data to write at that index. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00727">727</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="afe1b7e23f0d8cb0a251652942448106f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1b7e23f0d8cb0a251652942448106f">&#9670;&nbsp;</a></span>write() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , ArrayType ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataT &amp;&amp;&#160;</td>
          <td class="paramname"><em>dat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to write at </td></tr>
    <tr><td class="paramname">dat</td><td>The data to write at that index. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00737">737</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/sparta/sparta/resources/<a class="el" href="Array_8hpp_source.html">Array.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li><li class="navelem"><a class="el" href="classsparta_1_1Array.html">Array</a></li>
    <li class="footer">Generated on Fri Sep 25 2020 04:28:27 for The Sparta Modeling Framework by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
