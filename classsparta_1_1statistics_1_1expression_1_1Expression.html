<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta::statistics::expression::Expression Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classsparta_1_1statistics_1_1expression_1_1Expression.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsparta_1_1statistics_1_1expression_1_1Expression-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sparta::statistics::expression::Expression Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html" title="Expression container/builder. Contains a single ExpressionNode representing the root of an expression...">Expression</a> container/builder. Contains a single <a class="el" href="classsparta_1_1statistics_1_1expression_1_1ExpressionNode.html" title="Abstract interface class for an item in an expression. Subclasses can contain other ExpressionNodes.">ExpressionNode</a> representing the root of an expression tree. This is the object on which the parser operates to build an expression incrementally through basic operators.  
 <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7d8417c61e2597561d2400081a45fda7"><td class="memItemLeft" align="right" valign="top"><a id="a7d8417c61e2597561d2400081a45fda7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a7d8417c61e2597561d2400081a45fda7">Expression</a> ()</td></tr>
<tr class="memdesc:a7d8417c61e2597561d2400081a45fda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an expression containing no content. <br /></td></tr>
<tr class="separator:a7d8417c61e2597561d2400081a45fda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd653680c102ce7bb4ff4e2c5c8b2ff"><td class="memItemLeft" align="right" valign="top"><a id="adbd653680c102ce7bb4ff4e2c5c8b2ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#adbd653680c102ce7bb4ff4e2c5c8b2ff">Expression</a> (const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;rhp)</td></tr>
<tr class="memdesc:adbd653680c102ce7bb4ff4e2c5c8b2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor. <br /></td></tr>
<tr class="separator:adbd653680c102ce7bb4ff4e2c5c8b2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387990fa7ece80c13be27302c40813cb"><td class="memItemLeft" align="right" valign="top"><a id="a387990fa7ece80c13be27302c40813cb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a387990fa7ece80c13be27302c40813cb">Expression</a> (<a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&amp;rhp)</td></tr>
<tr class="memdesc:a387990fa7ece80c13be27302c40813cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Constructor. <br /></td></tr>
<tr class="separator:a387990fa7ece80c13be27302c40813cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefcb2c3eaca0006b88c9e1c8646ac0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#afefcb2c3eaca0006b88c9e1c8646ac0f">Expression</a> (const std::string &amp;expression, <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *context)</td></tr>
<tr class="memdesc:afefcb2c3eaca0006b88c9e1c8646ac0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with string expression.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#afefcb2c3eaca0006b88c9e1c8646ac0f">More...</a><br /></td></tr>
<tr class="separator:afefcb2c3eaca0006b88c9e1c8646ac0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889873df98da52a349063c3ccb288868"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a889873df98da52a349063c3ccb288868">Expression</a> (const std::string &amp;expression, <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *context, std::vector&lt; const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;already_used)</td></tr>
<tr class="memdesc:a889873df98da52a349063c3ccb288868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with string expression.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a889873df98da52a349063c3ccb288868">More...</a><br /></td></tr>
<tr class="separator:a889873df98da52a349063c3ccb288868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4551bf218698b35150abc6742c69f39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aa4551bf218698b35150abc6742c69f39">Expression</a> (<a class="el" href="classsparta_1_1statistics_1_1expression_1_1ExpressionNode.html">ExpressionNode</a> *item)</td></tr>
<tr class="memdesc:aa4551bf218698b35150abc6742c69f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blind content constructor.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aa4551bf218698b35150abc6742c69f39">More...</a><br /></td></tr>
<tr class="separator:aa4551bf218698b35150abc6742c69f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3d759fafe3c174c7a6b1aa0481338a"><td class="memItemLeft" align="right" valign="top"><a id="a1d3d759fafe3c174c7a6b1aa0481338a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a1d3d759fafe3c174c7a6b1aa0481338a">Expression</a> (double d)</td></tr>
<tr class="memdesc:a1d3d759fafe3c174c7a6b1aa0481338a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsparta_1_1statistics_1_1expression_1_1Constant.html">Constant</a> construction. <br /></td></tr>
<tr class="separator:a1d3d759fafe3c174c7a6b1aa0481338a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727517a4c614af88a41e70b2568b2423"><td class="memItemLeft" align="right" valign="top"><a id="a727517a4c614af88a41e70b2568b2423"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a727517a4c614af88a41e70b2568b2423">Expression</a> (<a class="el" href="namespacesparta_1_1statistics_1_1expression.html#a1f06e1059ed2f8d69126873b81dd7af4">operation_t</a> type, <a class="el" href="classsparta_1_1statistics_1_1expression_1_1ExpressionNode.html">ExpressionNode</a> *op1, <a class="el" href="classsparta_1_1statistics_1_1expression_1_1ExpressionNode.html">ExpressionNode</a> *op2=nullptr, <a class="el" href="classsparta_1_1statistics_1_1expression_1_1ExpressionNode.html">ExpressionNode</a> *op3=nullptr)</td></tr>
<tr class="memdesc:a727517a4c614af88a41e70b2568b2423"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsparta_1_1statistics_1_1expression_1_1Operation.html" title="Operation Node (e.g. +,-,*,/)">Operation</a> construction. <br /></td></tr>
<tr class="separator:a727517a4c614af88a41e70b2568b2423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadad2ae60ff6ec9099e913bf10e7e386"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aadad2ae60ff6ec9099e913bf10e7e386">Expression</a> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *n, std::vector&lt; const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;used)</td></tr>
<tr class="memdesc:aadad2ae60ff6ec9099e913bf10e7e386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stat/Counter/Parameter construction.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aadad2ae60ff6ec9099e913bf10e7e386">More...</a><br /></td></tr>
<tr class="separator:aadad2ae60ff6ec9099e913bf10e7e386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8c562d45ac67b38e63da714e559ac6"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename ArgT &gt; </td></tr>
<tr class="memitem:a9a8c562d45ac67b38e63da714e559ac6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a9a8c562d45ac67b38e63da714e559ac6">Expression</a> (const std::string &amp;name, RetT(*fxn)(ArgT), const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;a)</td></tr>
<tr class="memdesc:a9a8c562d45ac67b38e63da714e559ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary function construction.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a9a8c562d45ac67b38e63da714e559ac6">More...</a><br /></td></tr>
<tr class="separator:a9a8c562d45ac67b38e63da714e559ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9897a5e940e62a5730e9cb0296cef5ab"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename ArgT &gt; </td></tr>
<tr class="memitem:a9897a5e940e62a5730e9cb0296cef5ab"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a9897a5e940e62a5730e9cb0296cef5ab">Expression</a> (const std::string &amp;name, std::function&lt; RetT(ArgT)&gt; &amp;, const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;a)</td></tr>
<tr class="memdesc:a9897a5e940e62a5730e9cb0296cef5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary function construction.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a9897a5e940e62a5730e9cb0296cef5ab">More...</a><br /></td></tr>
<tr class="separator:a9897a5e940e62a5730e9cb0296cef5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad53a6c060f074eb9937a05a7fa7b3b4"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename ArgT &gt; </td></tr>
<tr class="memitem:aad53a6c060f074eb9937a05a7fa7b3b4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aad53a6c060f074eb9937a05a7fa7b3b4">Expression</a> (const std::string &amp;name, RetT(*fxn)(ArgT, ArgT), const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;a, const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;b)</td></tr>
<tr class="memdesc:aad53a6c060f074eb9937a05a7fa7b3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary function construction.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aad53a6c060f074eb9937a05a7fa7b3b4">More...</a><br /></td></tr>
<tr class="separator:aad53a6c060f074eb9937a05a7fa7b3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d42da625497c7cd4ce068ade6490777"><td class="memTemplParams" colspan="2">template&lt;typename RetT &gt; </td></tr>
<tr class="memitem:a6d42da625497c7cd4ce068ade6490777"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a6d42da625497c7cd4ce068ade6490777">Expression</a> (const std::string &amp;name, const RetT &amp;functor, const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;a, const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;b)</td></tr>
<tr class="memdesc:a6d42da625497c7cd4ce068ade6490777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary function construction.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a6d42da625497c7cd4ce068ade6490777">More...</a><br /></td></tr>
<tr class="separator:a6d42da625497c7cd4ce068ade6490777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e4d91cfd88a1da3b843bd83b873d64"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename ArgT &gt; </td></tr>
<tr class="memitem:a65e4d91cfd88a1da3b843bd83b873d64"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a65e4d91cfd88a1da3b843bd83b873d64">Expression</a> (const std::string &amp;name, RetT(*fxn)(ArgT, ArgT, ArgT), const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;a, const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;b, const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;c)</td></tr>
<tr class="memdesc:a65e4d91cfd88a1da3b843bd83b873d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary function construction.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a65e4d91cfd88a1da3b843bd83b873d64">More...</a><br /></td></tr>
<tr class="separator:a65e4d91cfd88a1da3b843bd83b873d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a41ace93096409e0ed818c972d24c1"><td class="memItemLeft" align="right" valign="top"><a id="ac0a41ace93096409e0ed818c972d24c1"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#ac0a41ace93096409e0ed818c972d24c1">~Expression</a> ()</td></tr>
<tr class="memdesc:ac0a41ace93096409e0ed818c972d24c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:ac0a41ace93096409e0ed818c972d24c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa575d7e1f9d87b7e923da889ee342bef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aa575d7e1f9d87b7e923da889ee342bef">operator=</a> (const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;rhp)</td></tr>
<tr class="memdesc:aa575d7e1f9d87b7e923da889ee342bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. Clones the content of rhp and discards current expression content.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aa575d7e1f9d87b7e923da889ee342bef">More...</a><br /></td></tr>
<tr class="separator:aa575d7e1f9d87b7e923da889ee342bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb647f9eb278bd44d758c8f549c755df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aeb647f9eb278bd44d758c8f549c755df">operator=</a> (<a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&amp;rhp)</td></tr>
<tr class="memdesc:aeb647f9eb278bd44d758c8f549c755df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator with move. Moves content of rhp and discards current expression content.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aeb647f9eb278bd44d758c8f549c755df">More...</a><br /></td></tr>
<tr class="separator:aeb647f9eb278bd44d758c8f549c755df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558cf5d7892f85a904f3a4365cd35db8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1ExpressionNode.html">ExpressionNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a558cf5d7892f85a904f3a4365cd35db8">cloneContent</a> () const</td></tr>
<tr class="memdesc:a558cf5d7892f85a904f3a4365cd35db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a clone of the content of this expression.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a558cf5d7892f85a904f3a4365cd35db8">More...</a><br /></td></tr>
<tr class="separator:a558cf5d7892f85a904f3a4365cd35db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa918feec9e4a0e951cab2ea789e46a10"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aa918feec9e4a0e951cab2ea789e46a10">getStats</a> (std::vector&lt; const <a class="el" href="classsparta_1_1StatisticInstance.html">StatisticInstance</a> * &gt; &amp;results) const</td></tr>
<tr class="memdesc:aa918feec9e4a0e951cab2ea789e46a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the statistics present in this expression.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aa918feec9e4a0e951cab2ea789e46a10">More...</a><br /></td></tr>
<tr class="separator:aa918feec9e4a0e951cab2ea789e46a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a45959c3b36786e4f6e3322d589479"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a51a45959c3b36786e4f6e3322d589479">hasContent</a> () const</td></tr>
<tr class="memdesc:a51a45959c3b36786e4f6e3322d589479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this expression have content.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a51a45959c3b36786e4f6e3322d589479">More...</a><br /></td></tr>
<tr class="separator:a51a45959c3b36786e4f6e3322d589479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803e850d85d043cc0617788df1f0da2c"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename ArgT &gt; </td></tr>
<tr class="memitem:a803e850d85d043cc0617788df1f0da2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a803e850d85d043cc0617788df1f0da2c">ufunc</a> (const std::string &amp;name, RetT(*fxn)(ArgT), const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;a) const</td></tr>
<tr class="memdesc:a803e850d85d043cc0617788df1f0da2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a unary function having the given name and function.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a803e850d85d043cc0617788df1f0da2c">More...</a><br /></td></tr>
<tr class="separator:a803e850d85d043cc0617788df1f0da2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab398b83486595161183457dd1cfa275a"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename ArgT &gt; </td></tr>
<tr class="memitem:ab398b83486595161183457dd1cfa275a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#ab398b83486595161183457dd1cfa275a">ufunc</a> (const std::string &amp;name, std::function&lt; RetT(ArgT)&gt; &amp;, const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;a) const</td></tr>
<tr class="memdesc:ab398b83486595161183457dd1cfa275a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a unary function having the given name and functor.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#ab398b83486595161183457dd1cfa275a">More...</a><br /></td></tr>
<tr class="separator:ab398b83486595161183457dd1cfa275a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7b924f5cca61b9d508120852d6f4b8"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename ArgT &gt; </td></tr>
<tr class="memitem:aaa7b924f5cca61b9d508120852d6f4b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aaa7b924f5cca61b9d508120852d6f4b8">bfunc</a> (const std::string &amp;name, RetT(*fxn)(ArgT, ArgT), const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;a, const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;b) const</td></tr>
<tr class="memdesc:aaa7b924f5cca61b9d508120852d6f4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a binary function having the given name and function.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aaa7b924f5cca61b9d508120852d6f4b8">More...</a><br /></td></tr>
<tr class="separator:aaa7b924f5cca61b9d508120852d6f4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fec18b5ed3423ef90dd2a8b7205589d"><td class="memTemplParams" colspan="2">template&lt;typename RetT &gt; </td></tr>
<tr class="memitem:a9fec18b5ed3423ef90dd2a8b7205589d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a9fec18b5ed3423ef90dd2a8b7205589d">bfunc</a> (const std::string &amp;name, const RetT &amp;functor, const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;a, const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;b) const</td></tr>
<tr class="memdesc:a9fec18b5ed3423ef90dd2a8b7205589d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a binary function having the given name and functor.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a9fec18b5ed3423ef90dd2a8b7205589d">More...</a><br /></td></tr>
<tr class="separator:a9fec18b5ed3423ef90dd2a8b7205589d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0fd3af437de9cadbc7b3503eb6c725"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename ArgT &gt; </td></tr>
<tr class="memitem:a4c0fd3af437de9cadbc7b3503eb6c725"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a4c0fd3af437de9cadbc7b3503eb6c725">tfunc</a> (const std::string &amp;name, RetT(*fxn)(ArgT, ArgT, ArgT), const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;a, const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;b, const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;c) const</td></tr>
<tr class="memdesc:a4c0fd3af437de9cadbc7b3503eb6c725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a ternary function having the given name and function.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a4c0fd3af437de9cadbc7b3503eb6c725">More...</a><br /></td></tr>
<tr class="separator:a4c0fd3af437de9cadbc7b3503eb6c725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88762463579faaa0cd8e5fe000e7ae99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a88762463579faaa0cd8e5fe000e7ae99">operator=</a> (double d)</td></tr>
<tr class="memdesc:a88762463579faaa0cd8e5fe000e7ae99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a constant node.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a88762463579faaa0cd8e5fe000e7ae99">More...</a><br /></td></tr>
<tr class="separator:a88762463579faaa0cd8e5fe000e7ae99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04539fdef5873ea21a89f65424bf8f6"><td class="memItemLeft" align="right" valign="top"><a id="ab04539fdef5873ea21a89f65424bf8f6"></a>
<a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#ab04539fdef5873ea21a89f65424bf8f6">operator+</a> () const</td></tr>
<tr class="memdesc:ab04539fdef5873ea21a89f65424bf8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this expression with no effect. <br /></td></tr>
<tr class="separator:ab04539fdef5873ea21a89f65424bf8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27daeb5b60a1325d9d0d4b2d5b9067f"><td class="memItemLeft" align="right" valign="top"><a id="aa27daeb5b60a1325d9d0d4b2d5b9067f"></a>
<a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aa27daeb5b60a1325d9d0d4b2d5b9067f">operator-</a> () const</td></tr>
<tr class="memdesc:aa27daeb5b60a1325d9d0d4b2d5b9067f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this expression with a negation inserted. <br /></td></tr>
<tr class="separator:aa27daeb5b60a1325d9d0d4b2d5b9067f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324344ba520be5a872fdc2c2e0426061"><td class="memItemLeft" align="right" valign="top"><a id="a324344ba520be5a872fdc2c2e0426061"></a>
<a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a324344ba520be5a872fdc2c2e0426061">operator+</a> (const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;rhp) const</td></tr>
<tr class="memdesc:a324344ba520be5a872fdc2c2e0426061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new expression of: *this + rhp. <br /></td></tr>
<tr class="separator:a324344ba520be5a872fdc2c2e0426061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9830d491cb18fae7b406223fcf56eb"><td class="memItemLeft" align="right" valign="top"><a id="a7c9830d491cb18fae7b406223fcf56eb"></a>
<a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a7c9830d491cb18fae7b406223fcf56eb">operator-</a> (const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;rhp) const</td></tr>
<tr class="memdesc:a7c9830d491cb18fae7b406223fcf56eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new expression of: *this - rhp. <br /></td></tr>
<tr class="separator:a7c9830d491cb18fae7b406223fcf56eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba75caf201ad9a02eb4abb6cbc593fd2"><td class="memItemLeft" align="right" valign="top"><a id="aba75caf201ad9a02eb4abb6cbc593fd2"></a>
<a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aba75caf201ad9a02eb4abb6cbc593fd2">operator*</a> (const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;rhp) const</td></tr>
<tr class="memdesc:aba75caf201ad9a02eb4abb6cbc593fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new expression of: *this * rhp. <br /></td></tr>
<tr class="separator:aba75caf201ad9a02eb4abb6cbc593fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64f09b834fda11f4990ef8d2b96d44f"><td class="memItemLeft" align="right" valign="top"><a id="aa64f09b834fda11f4990ef8d2b96d44f"></a>
<a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#aa64f09b834fda11f4990ef8d2b96d44f">operator/</a> (const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;rhp) const</td></tr>
<tr class="memdesc:aa64f09b834fda11f4990ef8d2b96d44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new expression of: *this / rhp. <br /></td></tr>
<tr class="separator:aa64f09b834fda11f4990ef8d2b96d44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da4aa890540c2c064471601af819cc7"><td class="memItemLeft" align="right" valign="top"><a id="a5da4aa890540c2c064471601af819cc7"></a>
<a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a5da4aa890540c2c064471601af819cc7">operator+=</a> (const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;rhp)</td></tr>
<tr class="memdesc:a5da4aa890540c2c064471601af819cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this expression with a node adding rhp. <br /></td></tr>
<tr class="separator:a5da4aa890540c2c064471601af819cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9327f001af793b94add36e779c63e690"><td class="memItemLeft" align="right" valign="top"><a id="a9327f001af793b94add36e779c63e690"></a>
<a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a9327f001af793b94add36e779c63e690">operator-=</a> (const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;rhp)</td></tr>
<tr class="memdesc:a9327f001af793b94add36e779c63e690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this expression with a node subtracting rhp. <br /></td></tr>
<tr class="separator:a9327f001af793b94add36e779c63e690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477c7bfda78a8dca826ad6e2bac6b28c"><td class="memItemLeft" align="right" valign="top"><a id="a477c7bfda78a8dca826ad6e2bac6b28c"></a>
<a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a477c7bfda78a8dca826ad6e2bac6b28c">operator*=</a> (const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;rhp)</td></tr>
<tr class="memdesc:a477c7bfda78a8dca826ad6e2bac6b28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this expression with a node multiplying by rhp. <br /></td></tr>
<tr class="separator:a477c7bfda78a8dca826ad6e2bac6b28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8ffdc6f53947cf297e3690ae6d3773"><td class="memItemLeft" align="right" valign="top"><a id="abd8ffdc6f53947cf297e3690ae6d3773"></a>
<a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#abd8ffdc6f53947cf297e3690ae6d3773">operator/=</a> (const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;rhp)</td></tr>
<tr class="memdesc:abd8ffdc6f53947cf297e3690ae6d3773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this expression with a node dividing by rhp. <br /></td></tr>
<tr class="separator:abd8ffdc6f53947cf297e3690ae6d3773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a18ad267fa67d1948c45292980bfc8"><td class="memItemLeft" align="right" valign="top"><a id="a05a18ad267fa67d1948c45292980bfc8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a05a18ad267fa67d1948c45292980bfc8">evaluate</a> () const</td></tr>
<tr class="memdesc:a05a18ad267fa67d1948c45292980bfc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute value of this operate in simulation for the current computation window. <br /></td></tr>
<tr class="separator:a05a18ad267fa67d1948c45292980bfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1235cf64c35decd1fb7b5f0a02ee2c9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a1235cf64c35decd1fb7b5f0a02ee2c9a">start</a> ()</td></tr>
<tr class="memdesc:a1235cf64c35decd1fb7b5f0a02ee2c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify every item in this expression to start a new computation window.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a1235cf64c35decd1fb7b5f0a02ee2c9a">More...</a><br /></td></tr>
<tr class="separator:a1235cf64c35decd1fb7b5f0a02ee2c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56550284de2770211515eecb4c09243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#ac56550284de2770211515eecb4c09243">end</a> ()</td></tr>
<tr class="memdesc:ac56550284de2770211515eecb4c09243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify every item in this expression to end the current computation window.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#ac56550284de2770211515eecb4c09243">More...</a><br /></td></tr>
<tr class="separator:ac56550284de2770211515eecb4c09243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace068eb6f77022bde2a3456abba3d1ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#ace068eb6f77022bde2a3456abba3d1ce">dump</a> (std::ostream &amp;o, bool show_range=true, bool resolve_subexprs=true) const</td></tr>
<tr class="memdesc:ace068eb6f77022bde2a3456abba3d1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the content of this entire expression to an ostream.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#ace068eb6f77022bde2a3456abba3d1ce">More...</a><br /></td></tr>
<tr class="separator:ace068eb6f77022bde2a3456abba3d1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9251415dd9b4148fce5c89a9654eb76"><td class="memItemLeft" align="right" valign="top"><a id="ae9251415dd9b4148fce5c89a9654eb76"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>supportsCompression</b> () const</td></tr>
<tr class="separator:ae9251415dd9b4148fce5c89a9654eb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c386f496df0dfcdcd081550ff28502"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a54c386f496df0dfcdcd081550ff28502">stringize</a> (bool show_range=true, bool resolve_subexprs=true) const</td></tr>
<tr class="memdesc:a54c386f496df0dfcdcd081550ff28502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string representing this expression including any <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> dependencies.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a54c386f496df0dfcdcd081550ff28502">More...</a><br /></td></tr>
<tr class="separator:a54c386f496df0dfcdcd081550ff28502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cb09e4d3aa6ca4ad792a4856aad57b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#af7cb09e4d3aa6ca4ad792a4856aad57b">getClock</a> ()</td></tr>
<tr class="memdesc:af7cb09e4d3aa6ca4ad792a4856aad57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the clock associated with the content of this expression. This is done by finding all TreeNodes on which the <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html" title="Expression container/builder. Contains a single ExpressionNode representing the root of an expression...">Expression</a> depends.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#af7cb09e4d3aa6ca4ad792a4856aad57b">More...</a><br /></td></tr>
<tr class="separator:af7cb09e4d3aa6ca4ad792a4856aad57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47421241869fb96b4ac95ba7ce40bd39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a47421241869fb96b4ac95ba7ce40bd39">getClocks</a> (std::vector&lt; const <a class="el" href="classsparta_1_1Clock.html">Clock</a> * &gt; &amp;clocks) const</td></tr>
<tr class="memdesc:a47421241869fb96b4ac95ba7ce40bd39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all clocks associated with this <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html" title="Expression container/builder. Contains a single ExpressionNode representing the root of an expression...">Expression</a>.  <a href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a47421241869fb96b4ac95ba7ce40bd39">More...</a><br /></td></tr>
<tr class="separator:a47421241869fb96b4ac95ba7ce40bd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html" title="Expression container/builder. Contains a single ExpressionNode representing the root of an expression...">Expression</a> container/builder. Contains a single <a class="el" href="classsparta_1_1statistics_1_1expression_1_1ExpressionNode.html" title="Abstract interface class for an item in an expression. Subclasses can contain other ExpressionNodes.">ExpressionNode</a> representing the root of an expression tree. This is the object on which the parser operates to build an expression incrementally through basic operators. </p>
<dl class="section note"><dt>Note</dt><dd>Any TreeNodes referenced by an expression should outlast it. It is not safe to evaluate or even print the expression if any its references are destructed because they will leave dangling pointers.</dd></dl>
<p>Expressions have an inherit computation window built in (like <a class="el" href="classsparta_1_1StatisticDef.html" title="Contains a statistic definition (some useful information which can be computed)">StatisticDef</a>). This means that when the expression is created, any counter or stat-def referenced is treated as if it was 0 at that point. When the expression is later evaluated, the delta for those counters or stat-defs is used. This can be avoided simply by evaluating with evaluateAbsolute (generally not recommended)</p>
<p>If expressions created during different simulation states are joined together, then they may see different windows. This is intentional so that comparisons can be made between different simulation time windows in a single expression (most users will not need to do this). This issue can be avoided by manually calling <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a1235cf64c35decd1fb7b5f0a02ee2c9a" title="Notify every item in this expression to start a new computation window.">start()</a> </p>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00055">55</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afefcb2c3eaca0006b88c9e1c8646ac0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefcb2c3eaca0006b88c9e1c8646ac0f">&#9670;&nbsp;</a></span>Expression() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sparta::statistics::expression::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct with string expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>String containing an arithmetic expression </td></tr>
    <tr><td class="paramname">context</td><td><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> from which variables in the expression will be searched for. Must not be nullptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a889873df98da52a349063c3ccb288868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889873df98da52a349063c3ccb288868">&#9670;&nbsp;</a></span>Expression() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sparta::statistics::expression::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>already_used</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct with string expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>String containing an arithmetic expression </td></tr>
    <tr><td class="paramname">context</td><td>Optional <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> from which variables in the expression will be searched for. Must not be nullptr </td></tr>
    <tr><td class="paramname">already_used</td><td>TreeNodes already in an expression containing this expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4551bf218698b35150abc6742c69f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4551bf218698b35150abc6742c69f39">&#9670;&nbsp;</a></span>Expression() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparta::statistics::expression::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1ExpressionNode.html">ExpressionNode</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blind content constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html" title="Expression container/builder. Contains a single ExpressionNode representing the root of an expression...">Expression</a> item to contain. Takes ownership </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00120">120</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>

</div>
</div>
<a id="aadad2ae60ff6ec9099e913bf10e7e386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadad2ae60ff6ec9099e913bf10e7e386">&#9670;&nbsp;</a></span>Expression() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sparta::statistics::expression::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>used</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stat/Counter/Parameter construction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Node to use (<a class="el" href="classsparta_1_1StatisticDef.html" title="Contains a statistic definition (some useful information which can be computed)">StatisticDef</a>, <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a>, or <a class="el" href="classsparta_1_1Counter.html" title="Represents a counter of type counter_type (uint64_t). 2 and greater than 0 with a ceiling specified....">Counter</a> variant) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">used</td><td>Vector of nodes already used higher up in an enclosing expression (for preventing cycles). Use a dummy object if there is no chance of cyclic expressions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a8c562d45ac67b38e63da714e559ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8c562d45ac67b38e63da714e559ac6">&#9670;&nbsp;</a></span>Expression() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename ArgT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparta::statistics::expression::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RetT(*)(ArgT)&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary function construction. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RetT</td><td>Return type of function pointer. Must be convertable to double </td></tr>
    <tr><td class="paramname">ArgT</td><td>Argument type of function pointer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00568">568</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1statistics_1_1expression_1_1Expression_a9a8c562d45ac67b38e63da714e559ac6_cgraph.png" border="0" usemap="#aclasssparta_1_1statistics_1_1expression_1_1Expression_a9a8c562d45ac67b38e63da714e559ac6_cgraph" alt=""/></div>
<map name="classsparta_1_1statistics_1_1expression_1_1Expression_a9a8c562d45ac67b38e63da714e559ac6_cgraph" id="aclasssparta_1_1statistics_1_1expression_1_1Expression_a9a8c562d45ac67b38e63da714e559ac6_cgraph">
<area shape="rect" title="Unary function construction." alt="" coords="5,5,164,61"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a558cf5d7892f85a904f3a4365cd35db8" title="Makes a clone of the content of this expression." alt="" coords="212,5,371,61"/>
</map>
</div>

</div>
</div>
<a id="a9897a5e940e62a5730e9cb0296cef5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9897a5e940e62a5730e9cb0296cef5ab">&#9670;&nbsp;</a></span>Expression() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename ArgT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparta::statistics::expression::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; RetT(ArgT)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary function construction. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RetT</td><td>Return type of functor. Must be convertable to double </td></tr>
    <tr><td class="paramname">ArgT</td><td>Argument type of functor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00577">577</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1statistics_1_1expression_1_1Expression_a9897a5e940e62a5730e9cb0296cef5ab_cgraph.png" border="0" usemap="#aclasssparta_1_1statistics_1_1expression_1_1Expression_a9897a5e940e62a5730e9cb0296cef5ab_cgraph" alt=""/></div>
<map name="classsparta_1_1statistics_1_1expression_1_1Expression_a9897a5e940e62a5730e9cb0296cef5ab_cgraph" id="aclasssparta_1_1statistics_1_1expression_1_1Expression_a9897a5e940e62a5730e9cb0296cef5ab_cgraph">
<area shape="rect" title="Unary function construction." alt="" coords="5,5,164,61"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a558cf5d7892f85a904f3a4365cd35db8" title="Makes a clone of the content of this expression." alt="" coords="212,5,371,61"/>
</map>
</div>

</div>
</div>
<a id="aad53a6c060f074eb9937a05a7fa7b3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad53a6c060f074eb9937a05a7fa7b3b4">&#9670;&nbsp;</a></span>Expression() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename ArgT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparta::statistics::expression::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RetT(*)(ArgT, ArgT)&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary function construction. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RetT</td><td>Return type of function pointer. Must be convertable to double </td></tr>
    <tr><td class="paramname">ArgT</td><td>Argument type of function pointer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00586">586</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1statistics_1_1expression_1_1Expression_aad53a6c060f074eb9937a05a7fa7b3b4_cgraph.png" border="0" usemap="#aclasssparta_1_1statistics_1_1expression_1_1Expression_aad53a6c060f074eb9937a05a7fa7b3b4_cgraph" alt=""/></div>
<map name="classsparta_1_1statistics_1_1expression_1_1Expression_aad53a6c060f074eb9937a05a7fa7b3b4_cgraph" id="aclasssparta_1_1statistics_1_1expression_1_1Expression_aad53a6c060f074eb9937a05a7fa7b3b4_cgraph">
<area shape="rect" title="Binary function construction." alt="" coords="5,5,164,61"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a558cf5d7892f85a904f3a4365cd35db8" title="Makes a clone of the content of this expression." alt="" coords="212,5,371,61"/>
</map>
</div>

</div>
</div>
<a id="a6d42da625497c7cd4ce068ade6490777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d42da625497c7cd4ce068ade6490777">&#9670;&nbsp;</a></span>Expression() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparta::statistics::expression::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RetT &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary function construction. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RetT</td><td>Return type of functor. Must be convertable to double </td></tr>
    <tr><td class="paramname">ArgT</td><td>Argument type of functor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00596">596</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1statistics_1_1expression_1_1Expression_a6d42da625497c7cd4ce068ade6490777_cgraph.png" border="0" usemap="#aclasssparta_1_1statistics_1_1expression_1_1Expression_a6d42da625497c7cd4ce068ade6490777_cgraph" alt=""/></div>
<map name="classsparta_1_1statistics_1_1expression_1_1Expression_a6d42da625497c7cd4ce068ade6490777_cgraph" id="aclasssparta_1_1statistics_1_1expression_1_1Expression_a6d42da625497c7cd4ce068ade6490777_cgraph">
<area shape="rect" title="Binary function construction." alt="" coords="5,5,164,61"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a558cf5d7892f85a904f3a4365cd35db8" title="Makes a clone of the content of this expression." alt="" coords="212,5,371,61"/>
</map>
</div>

</div>
</div>
<a id="a65e4d91cfd88a1da3b843bd83b873d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e4d91cfd88a1da3b843bd83b873d64">&#9670;&nbsp;</a></span>Expression() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename ArgT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparta::statistics::expression::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RetT(*)(ArgT, ArgT, ArgT)&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary function construction. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RetT</td><td>Return type of function pointer. Must be convertable to double </td></tr>
    <tr><td class="paramname">ArgT</td><td>Argument type of function pointer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00604">604</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1statistics_1_1expression_1_1Expression_a65e4d91cfd88a1da3b843bd83b873d64_cgraph.png" border="0" usemap="#aclasssparta_1_1statistics_1_1expression_1_1Expression_a65e4d91cfd88a1da3b843bd83b873d64_cgraph" alt=""/></div>
<map name="classsparta_1_1statistics_1_1expression_1_1Expression_a65e4d91cfd88a1da3b843bd83b873d64_cgraph" id="aclasssparta_1_1statistics_1_1expression_1_1Expression_a65e4d91cfd88a1da3b843bd83b873d64_cgraph">
<area shape="rect" title="Ternary function construction." alt="" coords="5,5,164,61"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a558cf5d7892f85a904f3a4365cd35db8" title="Makes a clone of the content of this expression." alt="" coords="212,5,371,61"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9fec18b5ed3423ef90dd2a8b7205589d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fec18b5ed3423ef90dd2a8b7205589d">&#9670;&nbsp;</a></span>bfunc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> sparta::statistics::expression::Expression::bfunc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RetT &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a binary function having the given name and functor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RetT</td><td>Return type of functor. Must be convertable to double </td></tr>
    <tr><td class="paramname">ArgT</td><td>Argument type of functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the function (e.g. fabs) </td></tr>
    <tr><td class="paramname">fxn</td><td>Functor to invoke to compute the value. Must not be null </td></tr>
    <tr><td class="paramname">a</td><td>Operand 1 of the binary function </td></tr>
    <tr><td class="paramname">b</td><td>Operand 2 of the binary function </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00644">644</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1statistics_1_1expression_1_1Expression_a9fec18b5ed3423ef90dd2a8b7205589d_cgraph.png" border="0" usemap="#aclasssparta_1_1statistics_1_1expression_1_1Expression_a9fec18b5ed3423ef90dd2a8b7205589d_cgraph" alt=""/></div>
<map name="classsparta_1_1statistics_1_1expression_1_1Expression_a9fec18b5ed3423ef90dd2a8b7205589d_cgraph" id="aclasssparta_1_1statistics_1_1expression_1_1Expression_a9fec18b5ed3423ef90dd2a8b7205589d_cgraph">
<area shape="rect" title="Construct a binary function having the given name and functor." alt="" coords="5,45,164,101"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a558cf5d7892f85a904f3a4365cd35db8" title="Makes a clone of the content of this expression." alt="" coords="212,5,371,61"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a7d8417c61e2597561d2400081a45fda7" title="Constructs an expression containing no content." alt="" coords="212,85,371,141"/>
</map>
</div>

</div>
</div>
<a id="aaa7b924f5cca61b9d508120852d6f4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7b924f5cca61b9d508120852d6f4b8">&#9670;&nbsp;</a></span>bfunc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename ArgT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> sparta::statistics::expression::Expression::bfunc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RetT(*)(ArgT, ArgT)&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a binary function having the given name and function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RetT</td><td>Return type of function pointer. Must be convertable to double </td></tr>
    <tr><td class="paramname">ArgT</td><td>Argument type of function pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the function (e.g. fabs) </td></tr>
    <tr><td class="paramname">fxn</td><td>Function pointer to invoke to compute the value. Must not be nullptr </td></tr>
    <tr><td class="paramname">a</td><td>Operand 1 of the binary function </td></tr>
    <tr><td class="paramname">b</td><td>Operand 2 of the binary function </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00634">634</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1statistics_1_1expression_1_1Expression_aaa7b924f5cca61b9d508120852d6f4b8_cgraph.png" border="0" usemap="#aclasssparta_1_1statistics_1_1expression_1_1Expression_aaa7b924f5cca61b9d508120852d6f4b8_cgraph" alt=""/></div>
<map name="classsparta_1_1statistics_1_1expression_1_1Expression_aaa7b924f5cca61b9d508120852d6f4b8_cgraph" id="aclasssparta_1_1statistics_1_1expression_1_1Expression_aaa7b924f5cca61b9d508120852d6f4b8_cgraph">
<area shape="rect" title="Construct a binary function having the given name and function." alt="" coords="5,45,164,101"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a558cf5d7892f85a904f3a4365cd35db8" title="Makes a clone of the content of this expression." alt="" coords="212,5,371,61"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a7d8417c61e2597561d2400081a45fda7" title="Constructs an expression containing no content." alt="" coords="212,85,371,141"/>
</map>
</div>

</div>
</div>
<a id="a558cf5d7892f85a904f3a4365cd35db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558cf5d7892f85a904f3a4365cd35db8">&#9670;&nbsp;</a></span>cloneContent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1ExpressionNode.html">ExpressionNode</a>* sparta::statistics::expression::Expression::cloneContent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a clone of the content of this expression. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if this node has null content </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00247">247</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>

</div>
</div>
<a id="ace068eb6f77022bde2a3456abba3d1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace068eb6f77022bde2a3456abba3d1ce">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::statistics::expression::Expression::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_range</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resolve_subexprs</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the content of this entire expression to an ostream. </p>
<dl class="section note"><dt>Note</dt><dd>Does not evaluate the expression </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>Ostream to write to </td></tr>
    <tr><td class="paramname">show_range</td><td>Should the range be shown in any subexpression nodes. </td></tr>
    <tr><td class="paramname">resolve_subexprs</td><td>Should any referenced statistic defs be expanded to their full expressions so that this becomes an expression containing only counters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00463">463</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>

</div>
</div>
<a id="ac56550284de2770211515eecb4c09243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56550284de2770211515eecb4c09243">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::statistics::expression::Expression::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify every item in this expression to end the current computation window. </p>
<dl class="section note"><dt>Note</dt><dd>Has no effect if this expression has no content </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsparta_1_1StatisticInstance.html" title="Instance of either a StatisticDef or CounterBase or an Expression. Has a sample window (simulator tic...">sparta::StatisticInstance</a> </dd>
<dd>
<a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a51a45959c3b36786e4f6e3322d589479" title="Does this expression have content.">hasContent</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00447">447</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>

</div>
</div>
<a id="af7cb09e4d3aa6ca4ad792a4856aad57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7cb09e4d3aa6ca4ad792a4856aad57b">&#9670;&nbsp;</a></span>getClock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsparta_1_1Clock.html">Clock</a>* sparta::statistics::expression::Expression::getClock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the clock associated with the content of this expression. This is done by finding all TreeNodes on which the <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html" title="Expression container/builder. Contains a single ExpressionNode representing the root of an expression...">Expression</a> depends. </p>
<dl class="section return"><dt>Returns</dt><dd>The clock if at least one <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> is found in this expression and all found TreeNodes have the same clock. Returns nullptr if this <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html" title="Expression container/builder. Contains a single ExpressionNode representing the root of an expression...">Expression</a> contains no TreeNodes or none of those nodes have associated Clocks. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00504">504</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1statistics_1_1expression_1_1Expression_af7cb09e4d3aa6ca4ad792a4856aad57b_cgraph.png" border="0" usemap="#aclasssparta_1_1statistics_1_1expression_1_1Expression_af7cb09e4d3aa6ca4ad792a4856aad57b_cgraph" alt=""/></div>
<map name="classsparta_1_1statistics_1_1expression_1_1Expression_af7cb09e4d3aa6ca4ad792a4856aad57b_cgraph" id="aclasssparta_1_1statistics_1_1expression_1_1Expression_af7cb09e4d3aa6ca4ad792a4856aad57b_cgraph">
<area shape="rect" title="Gets the clock associated with the content of this expression. This is done by finding all TreeNodes ..." alt="" coords="5,45,164,101"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a47421241869fb96b4ac95ba7ce40bd39" title="Gets all clocks associated with this Expression." alt="" coords="212,5,371,61"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a54c386f496df0dfcdcd081550ff28502" title="Return a string representing this expression including any TreeNode dependencies." alt="" coords="212,85,371,141"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#ace068eb6f77022bde2a3456abba3d1ce" title="Write the content of this entire expression to an ostream." alt="" coords="419,93,616,134"/>
</map>
</div>

</div>
</div>
<a id="a47421241869fb96b4ac95ba7ce40bd39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47421241869fb96b4ac95ba7ce40bd39">&#9670;&nbsp;</a></span>getClocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::statistics::expression::Expression::getClocks </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classsparta_1_1Clock.html">Clock</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>clocks</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all clocks associated with this <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html" title="Expression container/builder. Contains a single ExpressionNode representing the root of an expression...">Expression</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clocks</td><td>Vector of clocks to which all clocks contained in this <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html" title="Expression container/builder. Contains a single ExpressionNode representing the root of an expression...">Expression</a> will be added. Does not clear this vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00526">526</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>

</div>
</div>
<a id="aa918feec9e4a0e951cab2ea789e46a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa918feec9e4a0e951cab2ea789e46a10">&#9670;&nbsp;</a></span>getStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::statistics::expression::Expression::getStats </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classsparta_1_1StatisticInstance.html">StatisticInstance</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the statistics present in this expression. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of stats added to results </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>Vector of pointers to StatisticInstances. All statistics within this class will be appended to the results vector. These pointers are valid until this expression is modified or deleted </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00261">261</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>

</div>
</div>
<a id="a51a45959c3b36786e4f6e3322d589479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a45959c3b36786e4f6e3322d589479">&#9670;&nbsp;</a></span>hasContent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::statistics::expression::Expression::hasContent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this expression have content. </p>
<dl class="section note"><dt>Note</dt><dd>This does not necessarily imply that the expression will be successfully evaluated </dd></dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00270">270</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>

</div>
</div>
<a id="aa575d7e1f9d87b7e923da889ee342bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa575d7e1f9d87b7e923da889ee342bef">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a>&amp; sparta::statistics::expression::Expression::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. Clones the content of rhp and discards current expression content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhp</td><td><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html" title="Expression container/builder. Contains a single ExpressionNode representing the root of an expression...">Expression</a> to copy content from </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00219">219</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>

</div>
</div>
<a id="a88762463579faaa0cd8e5fe000e7ae99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88762463579faaa0cd8e5fe000e7ae99">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp; sparta::statistics::expression::Expression::operator= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a constant node. </p>
<dl class="section note"><dt>Note</dt><dd>that this is a non-const operation </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00662">662</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>

</div>
</div>
<a id="aeb647f9eb278bd44d758c8f549c755df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb647f9eb278bd44d758c8f549c755df">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a>&amp; sparta::statistics::expression::Expression::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator with move. Moves content of rhp and discards current expression content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhp</td><td><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html" title="Expression container/builder. Contains a single ExpressionNode representing the root of an expression...">Expression</a> to move content from </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00235">235</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>

</div>
</div>
<a id="a1235cf64c35decd1fb7b5f0a02ee2c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1235cf64c35decd1fb7b5f0a02ee2c9a">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::statistics::expression::Expression::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify every item in this expression to start a new computation window. </p>
<dl class="section note"><dt>Note</dt><dd>Has no effect if this expression has no content </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsparta_1_1StatisticInstance.html" title="Instance of either a StatisticDef or CounterBase or an Expression. Has a sample window (simulator tic...">sparta::StatisticInstance</a> </dd>
<dd>
<a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a51a45959c3b36786e4f6e3322d589479" title="Does this expression have content.">hasContent</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00434">434</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>

</div>
</div>
<a id="a54c386f496df0dfcdcd081550ff28502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c386f496df0dfcdcd081550ff28502">&#9670;&nbsp;</a></span>stringize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sparta::statistics::expression::Expression::stringize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_range</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resolve_subexprs</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string representing this expression including any <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> dependencies. </p>
<dl class="section warning"><dt>Warning</dt><dd>It is not safe to call this if the expression depends on any destructed TreeNodes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">show_range</td><td>See dump </td></tr>
    <tr><td class="paramname">resolve_subexprs</td><td>See dump </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representation of this expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00489">489</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1statistics_1_1expression_1_1Expression_a54c386f496df0dfcdcd081550ff28502_cgraph.png" border="0" usemap="#aclasssparta_1_1statistics_1_1expression_1_1Expression_a54c386f496df0dfcdcd081550ff28502_cgraph" alt=""/></div>
<map name="classsparta_1_1statistics_1_1expression_1_1Expression_a54c386f496df0dfcdcd081550ff28502_cgraph" id="aclasssparta_1_1statistics_1_1expression_1_1Expression_a54c386f496df0dfcdcd081550ff28502_cgraph">
<area shape="rect" title="Return a string representing this expression including any TreeNode dependencies." alt="" coords="5,5,164,61"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#ace068eb6f77022bde2a3456abba3d1ce" title="Write the content of this entire expression to an ostream." alt="" coords="212,13,409,54"/>
</map>
</div>

</div>
</div>
<a id="a4c0fd3af437de9cadbc7b3503eb6c725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0fd3af437de9cadbc7b3503eb6c725">&#9670;&nbsp;</a></span>tfunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename ArgT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> sparta::statistics::expression::Expression::tfunc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RetT(*)(ArgT, ArgT, ArgT)&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a ternary function having the given name and function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RetT</td><td>Return type of function pointer. Must be convertable to double </td></tr>
    <tr><td class="paramname">ArgT</td><td>Argument type of function pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the function (e.g. fabs) </td></tr>
    <tr><td class="paramname">fxn</td><td>Function pointer to invoke to compute the value. Must not be nullptr </td></tr>
    <tr><td class="paramname">a</td><td>Operand 1 of the binary function </td></tr>
    <tr><td class="paramname">b</td><td>Operand 2 of the binary function </td></tr>
    <tr><td class="paramname">c</td><td>Operand 3 of the binary function </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00652">652</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1statistics_1_1expression_1_1Expression_a4c0fd3af437de9cadbc7b3503eb6c725_cgraph.png" border="0" usemap="#aclasssparta_1_1statistics_1_1expression_1_1Expression_a4c0fd3af437de9cadbc7b3503eb6c725_cgraph" alt=""/></div>
<map name="classsparta_1_1statistics_1_1expression_1_1Expression_a4c0fd3af437de9cadbc7b3503eb6c725_cgraph" id="aclasssparta_1_1statistics_1_1expression_1_1Expression_a4c0fd3af437de9cadbc7b3503eb6c725_cgraph">
<area shape="rect" title="Construct a ternary function having the given name and function." alt="" coords="5,45,164,101"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a558cf5d7892f85a904f3a4365cd35db8" title="Makes a clone of the content of this expression." alt="" coords="212,5,371,61"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a7d8417c61e2597561d2400081a45fda7" title="Constructs an expression containing no content." alt="" coords="212,85,371,141"/>
</map>
</div>

</div>
</div>
<a id="a803e850d85d043cc0617788df1f0da2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803e850d85d043cc0617788df1f0da2c">&#9670;&nbsp;</a></span>ufunc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename ArgT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> sparta::statistics::expression::Expression::ufunc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RetT(*)(ArgT)&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a unary function having the given name and function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RetT</td><td>Return type of function pointer. Must be convertable to double </td></tr>
    <tr><td class="paramname">ArgT</td><td>Argument type of function pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the function (e.g. fabs) </td></tr>
    <tr><td class="paramname">fxn</td><td>Function pointer to invoke to compute the value. Must not be nullptr </td></tr>
    <tr><td class="paramname">a</td><td>Operand of the unary function </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00615">615</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1statistics_1_1expression_1_1Expression_a803e850d85d043cc0617788df1f0da2c_cgraph.png" border="0" usemap="#aclasssparta_1_1statistics_1_1expression_1_1Expression_a803e850d85d043cc0617788df1f0da2c_cgraph" alt=""/></div>
<map name="classsparta_1_1statistics_1_1expression_1_1Expression_a803e850d85d043cc0617788df1f0da2c_cgraph" id="aclasssparta_1_1statistics_1_1expression_1_1Expression_a803e850d85d043cc0617788df1f0da2c_cgraph">
<area shape="rect" title="Construct a unary function having the given name and function." alt="" coords="5,45,164,101"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a558cf5d7892f85a904f3a4365cd35db8" title="Makes a clone of the content of this expression." alt="" coords="212,5,371,61"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a7d8417c61e2597561d2400081a45fda7" title="Constructs an expression containing no content." alt="" coords="212,85,371,141"/>
</map>
</div>

</div>
</div>
<a id="ab398b83486595161183457dd1cfa275a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab398b83486595161183457dd1cfa275a">&#9670;&nbsp;</a></span>ufunc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename ArgT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> sparta::statistics::expression::Expression::ufunc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; RetT(ArgT)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a unary function having the given name and functor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RetT</td><td>Return type of functor. Must be convertable to double </td></tr>
    <tr><td class="paramname">ArgT</td><td>Argument type of functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the function (e.g. fabs) </td></tr>
    <tr><td class="paramname">fxn</td><td>Functor to invoke to compute the value. Must not be null </td></tr>
    <tr><td class="paramname">a</td><td>Operand of the unary function </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Expression_8hpp_source.html#l00625">625</a> of file <a class="el" href="Expression_8hpp_source.html">Expression.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1statistics_1_1expression_1_1Expression_ab398b83486595161183457dd1cfa275a_cgraph.png" border="0" usemap="#aclasssparta_1_1statistics_1_1expression_1_1Expression_ab398b83486595161183457dd1cfa275a_cgraph" alt=""/></div>
<map name="classsparta_1_1statistics_1_1expression_1_1Expression_ab398b83486595161183457dd1cfa275a_cgraph" id="aclasssparta_1_1statistics_1_1expression_1_1Expression_ab398b83486595161183457dd1cfa275a_cgraph">
<area shape="rect" title="Construct a unary function having the given name and functor." alt="" coords="5,45,164,101"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a558cf5d7892f85a904f3a4365cd35db8" title="Makes a clone of the content of this expression." alt="" coords="212,5,371,61"/>
<area shape="rect" href="classsparta_1_1statistics_1_1expression_1_1Expression.html#a7d8417c61e2597561d2400081a45fda7" title="Constructs an expression containing no content." alt="" coords="212,85,371,141"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/sparta/sparta/statistics/<a class="el" href="Expression_8hpp_source.html">Expression.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li><li class="navelem"><a class="el" href="namespacesparta_1_1statistics.html">statistics</a></li><li class="navelem"><a class="el" href="namespacesparta_1_1statistics_1_1expression.html">expression</a></li><li class="navelem"><a class="el" href="classsparta_1_1statistics_1_1expression_1_1Expression.html">Expression</a></li>
    <li class="footer">Generated on Fri Sep 25 2020 04:28:32 for The Sparta Modeling Framework by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
