<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta::Queue&lt; DataT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classsparta_1_1Queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsparta_1_1Queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sparta::Queue&lt; DataT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A data structure that allows appending at the back and invalidating from the front.  
 <a href="classsparta_1_1Queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue_1_1QueueIterator.html">QueueIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that alows queue elements to be accessed like a normal stl iterator. <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a> iterator is a bidirectional sequential iterator <a class="el" href="classsparta_1_1Queue_1_1QueueIterator.html#a00789211ecb7a265ca881fa9a199e8a1">isValid()</a> method checks the validity of the iterator. This method can be used to check if the data in <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a> has not yet been popped out Increment, decrement , dereferencing,less than and greater than operations are provided.  <a href="classsparta_1_1Queue_1_1QueueIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0c4199e572f28cbd566fd7310a3d56ee"><td class="memItemLeft" align="right" valign="top"><a id="a0c4199e572f28cbd566fd7310a3d56ee"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a> = DataT</td></tr>
<tr class="memdesc:a0c4199e572f28cbd566fd7310a3d56ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the DataT. <br /></td></tr>
<tr class="separator:a0c4199e572f28cbd566fd7310a3d56ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077bf94cecfd9554736e21e01a6aacbc"><td class="memItemLeft" align="right" valign="top"><a id="a077bf94cecfd9554736e21e01a6aacbc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a077bf94cecfd9554736e21e01a6aacbc">QueueType</a> = <a class="el" href="classsparta_1_1Queue.html">Queue</a>&lt; <a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a> &gt;</td></tr>
<tr class="memdesc:a077bf94cecfd9554736e21e01a6aacbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the QueueType. <br /></td></tr>
<tr class="separator:a077bf94cecfd9554736e21e01a6aacbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc60d8a8694b5f8b91c9bb8f65847dab"><td class="memItemLeft" align="right" valign="top"><a id="abc60d8a8694b5f8b91c9bb8f65847dab"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = uint32_t</td></tr>
<tr class="separator:abc60d8a8694b5f8b91c9bb8f65847dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603aad14e25d497d1edc474979990f9a"><td class="memItemLeft" align="right" valign="top"><a id="a603aad14e25d497d1edc474979990f9a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a603aad14e25d497d1edc474979990f9a">iterator</a> = <a class="el" href="classsparta_1_1Queue_1_1QueueIterator.html">QueueIterator</a>&lt; false &gt;</td></tr>
<tr class="memdesc:a603aad14e25d497d1edc474979990f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for regular iterator. <br /></td></tr>
<tr class="separator:a603aad14e25d497d1edc474979990f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849ec8b607eb5efdcae6db6b8a36789f"><td class="memItemLeft" align="right" valign="top"><a id="a849ec8b607eb5efdcae6db6b8a36789f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a849ec8b607eb5efdcae6db6b8a36789f">const_iterator</a> = <a class="el" href="classsparta_1_1Queue_1_1QueueIterator.html">QueueIterator</a>&lt; true &gt;</td></tr>
<tr class="memdesc:a849ec8b607eb5efdcae6db6b8a36789f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for constant iterator. <br /></td></tr>
<tr class="separator:a849ec8b607eb5efdcae6db6b8a36789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9ba14feab4949cd81c1ddec79c3ea7a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a9ba14feab4949cd81c1ddec79c3ea7a7">Queue</a> (const std::string &amp;name, const uint32_t num_entries, const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *clk, <a class="el" href="classsparta_1_1StatisticSet.html">StatisticSet</a> *statset=nullptr, <a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a> stat_vis_general=<a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a>, <a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a> stat_vis_detailed=<a class="el" href="classsparta_1_1InstrumentationNode.html#a855b6ecdd93e412052ae264032002ce1a01a69b1a50e88559f40efc68ba7e5224">InstrumentationNode::VIS_HIDDEN</a>, <a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a> stat_vis_max=<a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a>, <a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a> stat_vis_avg=<a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a>)</td></tr>
<tr class="memdesc:a9ba14feab4949cd81c1ddec79c3ea7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a queue.  <a href="classsparta_1_1Queue.html#a9ba14feab4949cd81c1ddec79c3ea7a7">More...</a><br /></td></tr>
<tr class="separator:a9ba14feab4949cd81c1ddec79c3ea7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71ed58d82b42382bff78e9f0b7ad0c6"><td class="memItemLeft" align="right" valign="top"><a id="ad71ed58d82b42382bff78e9f0b7ad0c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#ad71ed58d82b42382bff78e9f0b7ad0c6">~Queue</a> ()</td></tr>
<tr class="memdesc:ad71ed58d82b42382bff78e9f0b7ad0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a>, clearing everything out. <br /></td></tr>
<tr class="separator:ad71ed58d82b42382bff78e9f0b7ad0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c461bf0080d3ca449c08ce096b634f"><td class="memItemLeft" align="right" valign="top"><a id="a52c461bf0080d3ca449c08ce096b634f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a52c461bf0080d3ca449c08ce096b634f">Queue</a> (const <a class="el" href="classsparta_1_1Queue.html">Queue</a>&lt; <a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a> &gt; &amp;)=delete</td></tr>
<tr class="memdesc:a52c461bf0080d3ca449c08ce096b634f"><td class="mdescLeft">&#160;</td><td class="mdescRight">No copies, no moves. <br /></td></tr>
<tr class="separator:a52c461bf0080d3ca449c08ce096b634f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbd68c482013c4833e7df98a74c58ae"><td class="memItemLeft" align="right" valign="top"><a id="a9fbd68c482013c4833e7df98a74c58ae"></a>
<a class="el" href="classsparta_1_1Queue.html">Queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a9fbd68c482013c4833e7df98a74c58ae">operator=</a> (const <a class="el" href="classsparta_1_1Queue.html">Queue</a>&lt; <a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a> &gt; &amp;)=delete</td></tr>
<tr class="memdesc:a9fbd68c482013c4833e7df98a74c58ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleting default assignment operator to prevent copies. <br /></td></tr>
<tr class="separator:a9fbd68c482013c4833e7df98a74c58ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddf318a5fc96552d7587210d7ba28b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a2ddf318a5fc96552d7587210d7ba28b1">isValid</a> (uint32_t idx) const</td></tr>
<tr class="memdesc:a2ddf318a5fc96552d7587210d7ba28b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if data at the index is valid.  <a href="classsparta_1_1Queue.html#a2ddf318a5fc96552d7587210d7ba28b1">More...</a><br /></td></tr>
<tr class="separator:a2ddf318a5fc96552d7587210d7ba28b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6802d569d69070c8636db9884aedf7b8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a6802d569d69070c8636db9884aedf7b8">read</a> (uint32_t idx) const</td></tr>
<tr class="memdesc:a6802d569d69070c8636db9884aedf7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and return the data at the given index, const reference.  <a href="classsparta_1_1Queue.html#a6802d569d69070c8636db9884aedf7b8">More...</a><br /></td></tr>
<tr class="separator:a6802d569d69070c8636db9884aedf7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c17da7ad8d4d5c0179fd9d6a9c0a2eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a5c17da7ad8d4d5c0179fd9d6a9c0a2eb">access</a> (uint32_t idx)</td></tr>
<tr class="memdesc:a5c17da7ad8d4d5c0179fd9d6a9c0a2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and return the data at the given index, reference, non-const method.  <a href="classsparta_1_1Queue.html#a5c17da7ad8d4d5c0179fd9d6a9c0a2eb">More...</a><br /></td></tr>
<tr class="separator:a5c17da7ad8d4d5c0179fd9d6a9c0a2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267981cae48cb6488d282dadd2913154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a267981cae48cb6488d282dadd2913154">front</a> () const</td></tr>
<tr class="memdesc:a267981cae48cb6488d282dadd2913154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and return the data at the front(oldest element), reference.  <a href="classsparta_1_1Queue.html#a267981cae48cb6488d282dadd2913154">More...</a><br /></td></tr>
<tr class="separator:a267981cae48cb6488d282dadd2913154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9c66b39a04d9f771f1225db6932997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#afa9c66b39a04d9f771f1225db6932997">back</a> () const</td></tr>
<tr class="memdesc:afa9c66b39a04d9f771f1225db6932997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and return the last pushed in element(newest element), reference.  <a href="classsparta_1_1Queue.html#afa9c66b39a04d9f771f1225db6932997">More...</a><br /></td></tr>
<tr class="separator:afa9c66b39a04d9f771f1225db6932997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7031c894df6656d9643043bc0081f7e3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a7031c894df6656d9643043bc0081f7e3">capacity</a> () const</td></tr>
<tr class="memdesc:a7031c894df6656d9643043bc0081f7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fixed size of this queue.  <a href="classsparta_1_1Queue.html#a7031c894df6656d9643043bc0081f7e3">More...</a><br /></td></tr>
<tr class="separator:a7031c894df6656d9643043bc0081f7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d770819cbda5b70db6eff8f35b289b"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a61d770819cbda5b70db6eff8f35b289b">size</a> () const</td></tr>
<tr class="memdesc:a61d770819cbda5b70db6eff8f35b289b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of valid entries.  <a href="classsparta_1_1Queue.html#a61d770819cbda5b70db6eff8f35b289b">More...</a><br /></td></tr>
<tr class="separator:a61d770819cbda5b70db6eff8f35b289b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5281b9b23c7849f4135d9f69f079563d"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a5281b9b23c7849f4135d9f69f079563d">numFree</a> () const</td></tr>
<tr class="memdesc:a5281b9b23c7849f4135d9f69f079563d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of free entries.  <a href="classsparta_1_1Queue.html#a5281b9b23c7849f4135d9f69f079563d">More...</a><br /></td></tr>
<tr class="separator:a5281b9b23c7849f4135d9f69f079563d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6aa1902a440f69afe47d99bd988656"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a6a6aa1902a440f69afe47d99bd988656">empty</a> () const</td></tr>
<tr class="memdesc:a6a6aa1902a440f69afe47d99bd988656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the queue is empty or not.  <a href="classsparta_1_1Queue.html#a6a6aa1902a440f69afe47d99bd988656">More...</a><br /></td></tr>
<tr class="separator:a6a6aa1902a440f69afe47d99bd988656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24cbe3f872c8309010821ce92f05e01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#ae24cbe3f872c8309010821ce92f05e01">clear</a> ()</td></tr>
<tr class="memdesc:ae24cbe3f872c8309010821ce92f05e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the queue.  <a href="classsparta_1_1Queue.html#ae24cbe3f872c8309010821ce92f05e01">More...</a><br /></td></tr>
<tr class="separator:ae24cbe3f872c8309010821ce92f05e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d1e3c7245e95d489e7feb2aab1a4ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#ae0d1e3c7245e95d489e7feb2aab1a4ec">enableCollection</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent)</td></tr>
<tr class="memdesc:ae0d1e3c7245e95d489e7feb2aab1a4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that this queue begin collecting its contents for pipeline collection.  <a href="classsparta_1_1Queue.html#ae0d1e3c7245e95d489e7feb2aab1a4ec">More...</a><br /></td></tr>
<tr class="separator:ae0d1e3c7245e95d489e7feb2aab1a4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47006fe317f4f5f92c8380734d0ddb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Queue.html#a603aad14e25d497d1edc474979990f9a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#ab47006fe317f4f5f92c8380734d0ddb9">push</a> (const <a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a> &amp;dat)</td></tr>
<tr class="memdesc:ab47006fe317f4f5f92c8380734d0ddb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">push data to the <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a>.  <a href="classsparta_1_1Queue.html#ab47006fe317f4f5f92c8380734d0ddb9">More...</a><br /></td></tr>
<tr class="separator:ab47006fe317f4f5f92c8380734d0ddb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05c7cfdc0a0b41b84b48e8671ac982b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Queue.html#a603aad14e25d497d1edc474979990f9a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#ad05c7cfdc0a0b41b84b48e8671ac982b">push</a> (<a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a> &amp;&amp;dat)</td></tr>
<tr class="memdesc:ad05c7cfdc0a0b41b84b48e8671ac982b"><td class="mdescLeft">&#160;</td><td class="mdescRight">push data to the <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a>.  <a href="classsparta_1_1Queue.html#ad05c7cfdc0a0b41b84b48e8671ac982b">More...</a><br /></td></tr>
<tr class="separator:ad05c7cfdc0a0b41b84b48e8671ac982b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93a8b3c890ebb33773e4976e7977ea4"><td class="memItemLeft" align="right" valign="top"><a id="af93a8b3c890ebb33773e4976e7977ea4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#af93a8b3c890ebb33773e4976e7977ea4">pop</a> ()</td></tr>
<tr class="memdesc:af93a8b3c890ebb33773e4976e7977ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the data at the front of the structure (oldest element) After pop iterator always points to the last element. <br /></td></tr>
<tr class="separator:af93a8b3c890ebb33773e4976e7977ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a973e56dcbededf2d35ef6991f54a2"><td class="memItemLeft" align="right" valign="top"><a id="a97a973e56dcbededf2d35ef6991f54a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a97a973e56dcbededf2d35ef6991f54a2">pop_back</a> ()</td></tr>
<tr class="memdesc:a97a973e56dcbededf2d35ef6991f54a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the data at the back of the structure (newest element) After pop iterator always points to the last element. <br /></td></tr>
<tr class="separator:a97a973e56dcbededf2d35ef6991f54a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d66599df9273121fc5bb4c93cce0e8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Queue.html#a603aad14e25d497d1edc474979990f9a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a6d66599df9273121fc5bb4c93cce0e8f">begin</a> ()</td></tr>
<tr class="memdesc:a6d66599df9273121fc5bb4c93cce0e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like begin operation, starts at front (oldest element)  <a href="classsparta_1_1Queue.html#a6d66599df9273121fc5bb4c93cce0e8f">More...</a><br /></td></tr>
<tr class="separator:a6d66599df9273121fc5bb4c93cce0e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915dd6ca633073a011f76529959a269c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Queue.html#a603aad14e25d497d1edc474979990f9a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a915dd6ca633073a011f76529959a269c">end</a> ()</td></tr>
<tr class="memdesc:a915dd6ca633073a011f76529959a269c"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL - like end operation, starts at element one past head.  <a href="classsparta_1_1Queue.html#a915dd6ca633073a011f76529959a269c">More...</a><br /></td></tr>
<tr class="separator:a915dd6ca633073a011f76529959a269c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139eed99a7624631b7f00374be9527d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Queue.html#a849ec8b607eb5efdcae6db6b8a36789f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a139eed99a7624631b7f00374be9527d2">begin</a> () const</td></tr>
<tr class="memdesc:a139eed99a7624631b7f00374be9527d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like begin operation, starts at front (oldest element)  <a href="classsparta_1_1Queue.html#a139eed99a7624631b7f00374be9527d2">More...</a><br /></td></tr>
<tr class="separator:a139eed99a7624631b7f00374be9527d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf31c7e1c36cf6dd0b79dca6c502381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Queue.html#a849ec8b607eb5efdcae6db6b8a36789f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html#a5cf31c7e1c36cf6dd0b79dca6c502381">end</a> () const</td></tr>
<tr class="memdesc:a5cf31c7e1c36cf6dd0b79dca6c502381"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL - like end operation, starts at element one past head.  <a href="classsparta_1_1Queue.html#a5cf31c7e1c36cf6dd0b79dca6c502381">More...</a><br /></td></tr>
<tr class="separator:a5cf31c7e1c36cf6dd0b79dca6c502381"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class DataT&gt;<br />
class sparta::Queue&lt; DataT &gt;</h3>

<p>A data structure that allows appending at the back and invalidating from the front. </p>
<p>The <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a> allows user to push data to the back of the queue and pop it from the front.</p>
<p>The queue does not manage any type of state delaying. In order to use the queue as a present state/next state queue, the user should use delays when writing to the queue's ports or listening to the queue's ports.</p>
<p>The only precedence that the <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a> follows is that invalidations precede writes.</p>
<p>The queue can also be used without the port mechanism via public methods push and pop. The pop method is special in that it will return an iterator which points to that entry in <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a>. At any time the queue entry can be queried for that data's location in the queue via its public getIndex() method.</p>
<p>Example usage </p><div class="fragment"><div class="line">Queue&lt;uint32_t&gt; queue;</div>
<div class="line"><a class="code" href="classsparta_1_1Queue.html#a603aad14e25d497d1edc474979990f9a">Queue&lt;uint32_t&gt;::iterator</a> entry = queue.push(5);</div>
<div class="line"><a class="code" href="classsparta_1_1Queue.html#a603aad14e25d497d1edc474979990f9a">Queue&lt;uint32_t&gt;::iterator</a> entry2 = queue.push(52);</div>
<div class="line"><span class="comment">// where is the entry?</span></div>
<div class="line">uint32_t = entry.getIndex();</div>
<div class="line">assert(entry.getIndex() == 0);</div>
<div class="line">assert(entry2.getIndex() == 1);</div>
<div class="line">assert(queue.read(entry.getIndex() == 5));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// QueueIterator&#39;s respond to comparison operators. Their index is compared.</span></div>
<div class="line">assert(entry &lt; entry2);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">queue.pop();</div>
<div class="line">assert(entry2.getIndex() == 0);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00068">68</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9ba14feab4949cd81c1ddec79c3ea7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba14feab4949cd81c1ddec79c3ea7a7">&#9670;&nbsp;</a></span>Queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::<a class="el" href="classsparta_1_1Queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>num_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *&#160;</td>
          <td class="paramname"><em>clk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1StatisticSet.html">StatisticSet</a> *&#160;</td>
          <td class="paramname"><em>statset</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a>&#160;</td>
          <td class="paramname"><em>stat_vis_general</em> = <code><a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a>&#160;</td>
          <td class="paramname"><em>stat_vis_detailed</em> = <code><a class="el" href="classsparta_1_1InstrumentationNode.html#a855b6ecdd93e412052ae264032002ce1a01a69b1a50e88559f40efc68ba7e5224">InstrumentationNode::VIS_HIDDEN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a>&#160;</td>
          <td class="paramname"><em>stat_vis_max</em> = <code><a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a1c70a4a6f23a201659f6010b0e592dbd">InstrumentationNode::visibility_t</a>&#160;</td>
          <td class="paramname"><em>stat_vis_avg</em> = <code><a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the queue </td></tr>
    <tr><td class="paramname">num_entries</td><td>The number of entries this queue can hold </td></tr>
    <tr><td class="paramname">clk</td><td>The clock this queue belongs to </td></tr>
    <tr><td class="paramname">statset</td><td>The <a class="el" href="classsparta_1_1Counter.html" title="Represents a counter of type counter_type (uint64_t). 2 and greater than 0 with a ceiling specified....">Counter</a> set to register read-only counters; default nullptr</td></tr>
    <tr><td class="paramname">stat_vis_general</td><td>Sets the visibility of the stat counters for the 0th and last index of the utilization counts, so the empty and full counts.</td></tr>
    <tr><td class="paramname">stat_vis_detailed</td><td>Sets the visibility of the stat counts between 0 and the last index. i.e. more detailed than the general stats, default VIS_HIDDEN</td></tr>
    <tr><td class="paramname">stat_vis_max</td><td>Sets the visibility for a stat that contains the maximum utilization for this buffer. The default is AUTO_VISIBILITY.</td></tr>
    <tr><td class="paramname">stat_vis_avg</td><td>Sets the visibility for a stat that contains the weighted utilization average for this buffer. The default is AUTO_VISIBILITY.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>By default the stat_vis_* options are set to AUTO_VISIBILITY, for this structure AUTO_VISIBILITY resolves to SPARTA_CONTAINER_DEFAULT which at the time of writing this comment is set to VIS_HIDDEN. If you rely on the stats from this container you should explicity set the visibility. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00439">439</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5c17da7ad8d4d5c0179fd9d6a9c0a2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c17da7ad8d4d5c0179fd9d6a9c0a2eb">&#9670;&nbsp;</a></span>access()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a>&amp; <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::access </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read and return the data at the given index, reference, non-const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data to return at the given index (reference)</dd></dl>
<p>Use the <a class="el" href="classsparta_1_1Queue.html#a6802d569d69070c8636db9884aedf7b8" title="Read and return the data at the given index, const reference.">read()</a> equivalent for const access </p>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00507">507</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="afa9c66b39a04d9f771f1225db6932997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9c66b39a04d9f771f1225db6932997">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a>&amp; <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read and return the last pushed in element(newest element), reference. </p>
<dl class="section return"><dt>Returns</dt><dd>The data at the back (reference) </dd></dl>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00525">525</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="a6d66599df9273121fc5bb4c93cce0e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d66599df9273121fc5bb4c93cce0e8f">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Queue.html#a603aad14e25d497d1edc474979990f9a">iterator</a> <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like begin operation, starts at front (oldest element) </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the oldest element in <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00662">662</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="a139eed99a7624631b7f00374be9527d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139eed99a7624631b7f00374be9527d2">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Queue.html#a849ec8b607eb5efdcae6db6b8a36789f">const_iterator</a> <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like begin operation, starts at front (oldest element) </p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the oldest element in <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00677">677</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="a7031c894df6656d9643043bc0081f7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7031c894df6656d9643043bc0081f7e3">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the fixed size of this queue. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of this queue </dd></dl>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00536">536</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="ae24cbe3f872c8309010821ce92f05e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24cbe3f872c8309010821ce92f05e01">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty the queue. </p>
<p>Removes all entries from the <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a> </p>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00572">572</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="a6a6aa1902a440f69afe47d99bd988656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6aa1902a440f69afe47d99bd988656">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return if the queue is empty or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True, if the queue is empty</dd></dl>
<p>Does not take into account the number of invalidated entries <em>this</em> cycle </p>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00563">563</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="ae0d1e3c7245e95d489e7feb2aab1a4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d1e3c7245e95d489e7feb2aab1a4ec">&#9670;&nbsp;</a></span>enableCollection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::enableCollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request that this queue begin collecting its contents for pipeline collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>A pointer to the parent treenode for which to add Collectable objects under. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This only sets the <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a> up for collection. collection must be started with an instatiation of the PipelineCollector </dd></dl>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00595">595</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="a915dd6ca633073a011f76529959a269c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915dd6ca633073a011f76529959a269c">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Queue.html#a603aad14e25d497d1edc474979990f9a">iterator</a> <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL - like end operation, starts at element one past head. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns iterator pointing to past-the-end elemnt in <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00673">673</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="a5cf31c7e1c36cf6dd0b79dca6c502381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf31c7e1c36cf6dd0b79dca6c502381">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Queue.html#a849ec8b607eb5efdcae6db6b8a36789f">const_iterator</a> <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL - like end operation, starts at element one past head. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns const_iterator pointing to past-the-end elemnt in <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00688">688</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="a267981cae48cb6488d282dadd2913154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267981cae48cb6488d282dadd2913154">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a>&amp; <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read and return the data at the front(oldest element), reference. </p>
<dl class="section return"><dt>Returns</dt><dd>The data at the front (reference) </dd></dl>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00516">516</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="a2ddf318a5fc96552d7587210d7ba28b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddf318a5fc96552d7587210d7ba28b1">&#9670;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::isValid </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if data at the index is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to determine validity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid; false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00486">486</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="a5281b9b23c7849f4135d9f69f079563d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5281b9b23c7849f4135d9f69f079563d">&#9670;&nbsp;</a></span>numFree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::numFree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of free entries. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of free entries</dd></dl>
<p>Does not take into account the number of invalidated entries <em>this</em> cycle </p>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00553">553</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="ab47006fe317f4f5f92c8380734d0ddb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47006fe317f4f5f92c8380734d0ddb9">&#9670;&nbsp;</a></span>push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Queue.html#a603aad14e25d497d1edc474979990f9a">iterator</a> <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>dat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>push data to the <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dat</td><td>Data to be copied in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of a <a class="el" href="classsparta_1_1Queue_1_1QueueIterator.html" title="Class that alows queue elements to be accessed like a normal stl iterator. Queue iterator is a bidire...">QueueIterator</a> that can be queired at any time for this data's position in the queue. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>appends through via this method are immediately valid. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00607">607</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="ad05c7cfdc0a0b41b84b48e8671ac982b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05c7cfdc0a0b41b84b48e8671ac982b">&#9670;&nbsp;</a></span>push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Queue.html#a603aad14e25d497d1edc474979990f9a">iterator</a> <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>dat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>push data to the <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dat</td><td>Data to be moved in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of a <a class="el" href="classsparta_1_1Queue_1_1QueueIterator.html" title="Class that alows queue elements to be accessed like a normal stl iterator. Queue iterator is a bidire...">QueueIterator</a> that can be queired at any time for this data's position in the queue. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>appends through via this method are immediately valid. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00619">619</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="a6802d569d69070c8636db9884aedf7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6802d569d69070c8636db9884aedf7b8">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsparta_1_1Queue.html#a0c4199e572f28cbd566fd7310a3d56ee">value_type</a>&amp; <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read and return the data at the given index, const reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data to return at the given index (const reference) </dd></dl>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00495">495</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<a id="a61d770819cbda5b70db6eff8f35b289b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d770819cbda5b70db6eff8f35b289b">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classsparta_1_1Queue.html">sparta::Queue</a>&lt; DataT &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of valid entries. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of valid entries. Does not subtract entries invalidated <em>this</em> cycle </dd></dl>

<p class="definition">Definition at line <a class="el" href="Queue_8hpp_source.html#l00544">544</a> of file <a class="el" href="Queue_8hpp_source.html">Queue.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/sparta/sparta/resources/<a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclasssparta_1_1Queue_html_a603aad14e25d497d1edc474979990f9a"><div class="ttname"><a href="classsparta_1_1Queue.html#a603aad14e25d497d1edc474979990f9a">sparta::Queue::iterator</a></div><div class="ttdeci">QueueIterator&lt; false &gt; iterator</div><div class="ttdoc">Typedef for regular iterator.</div><div class="ttdef"><b>Definition:</b> <a href="Queue_8hpp_source.html#l00400">Queue.hpp:400</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li><li class="navelem"><a class="el" href="classsparta_1_1Queue.html">Queue</a></li>
    <li class="footer">Generated on Fri Sep 25 2020 04:28:29 for The Sparta Modeling Framework by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
