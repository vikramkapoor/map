<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta::app::ReportDescriptor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classsparta_1_1app_1_1ReportDescriptor.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classsparta_1_1app_1_1ReportDescriptor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sparta::app::ReportDescriptor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Describes one or more report to instantiate.  
 <a href="classsparta_1_1app_1_1ReportDescriptor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ReportDescriptor_8hpp_source.html">ReportDescriptor.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a82708eb1fbcc5407ec617b99e76660c8"><td class="memItemLeft" align="right" valign="top"><a id="a82708eb1fbcc5407ec617b99e76660c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a82708eb1fbcc5407ec617b99e76660c8">disable</a> ()</td></tr>
<tr class="memdesc:a82708eb1fbcc5407ec617b99e76660c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling this method causes the simulation to skip this descriptor when it is setting up its reports. This operation cannot be undone. <br /></td></tr>
<tr class="separator:a82708eb1fbcc5407ec617b99e76660c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924ed08a5e47bf965181d70ceb52befb"><td class="memItemLeft" align="right" valign="top"><a id="a924ed08a5e47bf965181d70ceb52befb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a924ed08a5e47bf965181d70ceb52befb">isEnabled</a> () const</td></tr>
<tr class="memdesc:a924ed08a5e47bf965181d70ceb52befb"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if this descriptor is enabled or not. Disabling a descriptor means that it will be filtered from report generation. <br /></td></tr>
<tr class="separator:a924ed08a5e47bf965181d70ceb52befb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf807ddd15df01d9b35ad84244002a9c"><td class="memItemLeft" align="right" valign="top"><a id="abf807ddd15df01d9b35ad84244002a9c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#abf807ddd15df01d9b35ad84244002a9c">isSingleTimeseriesReport</a> () const</td></tr>
<tr class="memdesc:abf807ddd15df01d9b35ad84244002a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this descriptor holds only one report instantiation, and that it is a timeseries report (.csv) <br /></td></tr>
<tr class="separator:abf807ddd15df01d9b35ad84244002a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed557054baf6694194942853b943b12d"><td class="memItemLeft" align="right" valign="top"><a id="aed557054baf6694194942853b943b12d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#aed557054baf6694194942853b943b12d">isSingleNonTimeseriesReport</a> () const</td></tr>
<tr class="memdesc:aed557054baf6694194942853b943b12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this descriptor holds only one report instantiation, and that it is <em>not</em> a timeseries report. For example, .html, .json, .txt, and so on. <br /></td></tr>
<tr class="separator:aed557054baf6694194942853b943b12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4accee4337e7e81e42bf88c7338a338d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a4accee4337e7e81e42bf88c7338a338d">configureAsyncTimeseriesReport</a> (simdb::AsyncTaskEval *task_queue, simdb::ObjectManager *sim_db, const <a class="el" href="classsparta_1_1Clock.html">Clock</a> &amp;root_clk)</td></tr>
<tr class="memdesc:a4accee4337e7e81e42bf88c7338a338d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch this descriptor's timeseries report generation from synchronous .csv generation to asynchronous database persistence.  <a href="classsparta_1_1app_1_1ReportDescriptor.html#a4accee4337e7e81e42bf88c7338a338d">More...</a><br /></td></tr>
<tr class="separator:a4accee4337e7e81e42bf88c7338a338d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc5eeb893665f711a7fdc0d47603fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a9bc5eeb893665f711a7fdc0d47603fce">configureAsyncNonTimeseriesReport</a> (simdb::AsyncTaskEval *task_queue, simdb::ObjectManager *sim_db)</td></tr>
<tr class="memdesc:a9bc5eeb893665f711a7fdc0d47603fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch this descriptor's report generation from synchronous to asynchronous database persistence. This method is intended only for descriptors that have just one <em>non-timeseries</em> report format.  <a href="classsparta_1_1app_1_1ReportDescriptor.html#a9bc5eeb893665f711a7fdc0d47603fce">More...</a><br /></td></tr>
<tr class="separator:a9bc5eeb893665f711a7fdc0d47603fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fa31d0480ea9cb210cf8329260b07d"><td class="memItemLeft" align="right" valign="top"><a id="a53fa31d0480ea9cb210cf8329260b07d"></a>
db::ReportHeader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a53fa31d0480ea9cb210cf8329260b07d">getTimeseriesDatabaseHeader</a> ()</td></tr>
<tr class="memdesc:a53fa31d0480ea9cb210cf8329260b07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give access to the database timeseries header. This will return null when this descriptor is used for any non- timeseries report format (json, json_reduced, txt, etc.) or when the "simdb" feature has been disabled. <br /></td></tr>
<tr class="separator:a53fa31d0480ea9cb210cf8329260b07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d688d0b8cad328b3aa95bb596c59db"><td class="memItemLeft" align="right" valign="top"><a id="a62d688d0b8cad328b3aa95bb596c59db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a62d688d0b8cad328b3aa95bb596c59db">doPostProcessing</a> (simdb::AsyncTaskEval *task_queue, simdb::ObjectManager *sim_db)</td></tr>
<tr class="memdesc:a62d688d0b8cad328b3aa95bb596c59db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do any post-simulation post processing steps needed. This is typically used for final wrap-up this descriptor needs to do in the simulation database, so the two inputs are the SimDB and the AsyncTaskEval objects that belong to the <a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">app::Simulation</a> and sparta::ReportRepository objects, but other non-database work may need to be completed post- simulation as well. <br /></td></tr>
<tr class="separator:a62d688d0b8cad328b3aa95bb596c59db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632dc73a0fef9a5415fe1f8d1c60578d"><td class="memItemLeft" align="right" valign="top"><a id="a632dc73a0fef9a5415fe1f8d1c60578d"></a>
std::map&lt; std::string, std::shared_ptr&lt; report::format::BaseFormatter &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a632dc73a0fef9a5415fe1f8d1c60578d">getFormattersByFilename</a> () const</td></tr>
<tr class="memdesc:a632dc73a0fef9a5415fe1f8d1c60578d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide access to the formatters we have been using so they can coordinate with the reporting infrastructure to write various metadata to the database. <br /></td></tr>
<tr class="separator:a632dc73a0fef9a5415fe1f8d1c60578d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c321bc8c1d2ca925ff641e5aaba80f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a7c321bc8c1d2ca925ff641e5aaba80f4">ReportDescriptor</a> (const std::string &amp;_loc_pattern, const std::string &amp;_def_file, const std::string &amp;_dest_file, const std::string &amp;_format=&quot;text&quot;)</td></tr>
<tr class="memdesc:a7c321bc8c1d2ca925ff641e5aaba80f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a report decsriptor.  <a href="classsparta_1_1app_1_1ReportDescriptor.html#a7c321bc8c1d2ca925ff641e5aaba80f4">More...</a><br /></td></tr>
<tr class="separator:a7c321bc8c1d2ca925ff641e5aaba80f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb6376d4369fb04c9a10ffe5c1b6b17"><td class="memItemLeft" align="right" valign="top"><a id="a7cb6376d4369fb04c9a10ffe5c1b6b17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a7cb6376d4369fb04c9a10ffe5c1b6b17">ReportDescriptor</a> (const <a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html">ReportDescriptor</a> &amp;)=default</td></tr>
<tr class="memdesc:a7cb6376d4369fb04c9a10ffe5c1b6b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow construction. <br /></td></tr>
<tr class="separator:a7cb6376d4369fb04c9a10ffe5c1b6b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa681501fa6d921b77ef9fe6d21b59b3f"><td class="memItemLeft" align="right" valign="top"><a id="aa681501fa6d921b77ef9fe6d21b59b3f"></a>
<a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html">ReportDescriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#aa681501fa6d921b77ef9fe6d21b59b3f">operator=</a> (const <a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html">ReportDescriptor</a> &amp;)=default</td></tr>
<tr class="memdesc:aa681501fa6d921b77ef9fe6d21b59b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow assignment. <br /></td></tr>
<tr class="separator:aa681501fa6d921b77ef9fe6d21b59b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f213d7b444bdd881cf91d5c0df4cfe"><td class="memItemLeft" align="right" valign="top"><a id="a05f213d7b444bdd881cf91d5c0df4cfe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a05f213d7b444bdd881cf91d5c0df4cfe">~ReportDescriptor</a> ()</td></tr>
<tr class="memdesc:a05f213d7b444bdd881cf91d5c0df4cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor (note that triggered reports are automatically flushed) <br /></td></tr>
<tr class="separator:a05f213d7b444bdd881cf91d5c0df4cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44491d3bb82b0b2fbca92a0bd48ea591"><td class="memItemLeft" align="right" valign="top"><a id="a44491d3bb82b0b2fbca92a0bd48ea591"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a44491d3bb82b0b2fbca92a0bd48ea591">getDescriptorPattern</a> () const</td></tr>
<tr class="memdesc:a44491d3bb82b0b2fbca92a0bd48ea591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for this descriptor's pattern, e.g. "_global". <br /></td></tr>
<tr class="separator:a44491d3bb82b0b2fbca92a0bd48ea591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13db539d47b355cbefd096d51abb14b0"><td class="memItemLeft" align="right" valign="top"><a id="a13db539d47b355cbefd096d51abb14b0"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a13db539d47b355cbefd096d51abb14b0">getDescriptorDefFile</a> () const</td></tr>
<tr class="memdesc:a13db539d47b355cbefd096d51abb14b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for this descriptor's def_file, e.g. "simple_stats.yaml". <br /></td></tr>
<tr class="separator:a13db539d47b355cbefd096d51abb14b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ed8b2e224885d6c79f12581b99c231"><td class="memItemLeft" align="right" valign="top"><a id="aa0ed8b2e224885d6c79f12581b99c231"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#aa0ed8b2e224885d6c79f12581b99c231">getDescriptorDestFile</a> () const</td></tr>
<tr class="memdesc:aa0ed8b2e224885d6c79f12581b99c231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for this descriptor's dest_file, e.g. "out.json". <br /></td></tr>
<tr class="separator:aa0ed8b2e224885d6c79f12581b99c231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9b6510e1a95cc4f8867c9071a2036e"><td class="memItemLeft" align="right" valign="top"><a id="a8c9b6510e1a95cc4f8867c9071a2036e"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a8c9b6510e1a95cc4f8867c9071a2036e">getDescriptorFormat</a> () const</td></tr>
<tr class="memdesc:a8c9b6510e1a95cc4f8867c9071a2036e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for this descriptor's format, e.g. "json_reduced". <br /></td></tr>
<tr class="separator:a8c9b6510e1a95cc4f8867c9071a2036e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0c1d20ca8b6a9b63bda251deedaed3"><td class="memItemLeft" align="right" valign="top"><a id="a6c0c1d20ca8b6a9b63bda251deedaed3"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a6c0c1d20ca8b6a9b63bda251deedaed3">getDescriptorOrigDestFile</a> () const</td></tr>
<tr class="memdesc:a6c0c1d20ca8b6a9b63bda251deedaed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">When SimDB has automatic report verification enabled, this descriptor may have had its dest_file changed when the Simulation::setupReports() method was called. The report file will still end up in the dest_file that you gave the descriptor, but this getter is added if you need to ask this descriptor what its immutable dest_file was from the beginning. <br /></td></tr>
<tr class="separator:a6c0c1d20ca8b6a9b63bda251deedaed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ae2b66486a692a3bf77c9532082a3d"><td class="memItemLeft" align="right" valign="top"><a id="ad1ae2b66486a692a3bf77c9532082a3d"></a>
std::shared_ptr&lt; <a class="el" href="classsparta_1_1statistics_1_1ReportStatisticsArchive.html">statistics::ReportStatisticsArchive</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#ad1ae2b66486a692a3bf77c9532082a3d">logOutputValuesToArchive</a> (const std::string &amp;dir)</td></tr>
<tr class="memdesc:ad1ae2b66486a692a3bf77c9532082a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the descriptor to send all of its writeOutput / updateOutput statistics values to a binary archive. Returns the archive object that will be responsible for feeding the data into the archive. Returns null if unable to connect to the database. <br /></td></tr>
<tr class="separator:ad1ae2b66486a692a3bf77c9532082a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a32d85c1675baac1c051e828ece5e5"><td class="memItemLeft" align="right" valign="top"><a id="a65a32d85c1675baac1c051e828ece5e5"></a>
std::shared_ptr&lt; <a class="el" href="classsparta_1_1statistics_1_1StreamNode.html">statistics::StreamNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a65a32d85c1675baac1c051e828ece5e5">createRootStatisticsStream</a> ()</td></tr>
<tr class="memdesc:a65a32d85c1675baac1c051e828ece5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a StreamNode object that sits at the top of a tree hierarchy that describes the Report/Subreport/StatisticInstance layout of this descriptor's report. <br /></td></tr>
<tr class="separator:a65a32d85c1675baac1c051e828ece5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f10a277aaa633e7be9ef374ba9ee5e"><td class="memItemLeft" align="right" valign="top"><a id="a90f10a277aaa633e7be9ef374ba9ee5e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a90f10a277aaa633e7be9ef374ba9ee5e">inspectSimulatorFeatureValues</a> (const <a class="el" href="classsparta_1_1app_1_1FeatureConfiguration.html">app::FeatureConfiguration</a> *feature_config)</td></tr>
<tr class="memdesc:a90f10a277aaa633e7be9ef374ba9ee5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the descriptor a chance to see the &ndash;feature values that were set at the command line, if any. This is called just prior to the main simulation loop. <br /></td></tr>
<tr class="separator:a90f10a277aaa633e7be9ef374ba9ee5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb975a7d55a0a34cbb7819f6b6f9bb39"><td class="memItemLeft" align="right" valign="top"><a id="acb975a7d55a0a34cbb7819f6b6f9bb39"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#acb975a7d55a0a34cbb7819f6b6f9bb39">ignoreFurtherUpdates</a> ()</td></tr>
<tr class="memdesc:acb975a7d55a0a34cbb7819f6b6f9bb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report descriptors may be triggered to stop early - ensure no further updates are written to disk. <br /></td></tr>
<tr class="separator:acb975a7d55a0a34cbb7819f6b6f9bb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9fa01eb04abbcc21e3345d05d74b93"><td class="memItemLeft" align="right" valign="top"><a id="acd9fa01eb04abbcc21e3345d05d74b93"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#acd9fa01eb04abbcc21e3345d05d74b93">stringize</a> () const</td></tr>
<tr class="memdesc:acd9fa01eb04abbcc21e3345d05d74b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents this descriptor as a string. <br /></td></tr>
<tr class="separator:acd9fa01eb04abbcc21e3345d05d74b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c25701cf3e7c2583657bed041c65d68"><td class="memItemLeft" align="right" valign="top">report::format::BaseFormatter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a6c25701cf3e7c2583657bed041c65d68">addInstantiation</a> (Report *r, <a class="el" href="classsparta_1_1app_1_1Simulation.html">Simulation</a> *sim, std::ostream *out=nullptr)</td></tr>
<tr class="memdesc:a6c25701cf3e7c2583657bed041c65d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks a report instantiated based on this descriptor and allocates a new formatter for it. Later, these tracked reports can be iterated and saved to different destinations (or the same) depending on their order.  <a href="classsparta_1_1app_1_1ReportDescriptor.html#a6c25701cf3e7c2583657bed041c65d68">More...</a><br /></td></tr>
<tr class="separator:a6c25701cf3e7c2583657bed041c65d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29c89bdfae66a91b1f166dc35059ade"><td class="memItemLeft" align="right" valign="top"><a id="ad29c89bdfae66a91b1f166dc35059ade"></a>
std::vector&lt; inst_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#ad29c89bdfae66a91b1f166dc35059ade">getInstantiations</a> () const</td></tr>
<tr class="memdesc:ad29c89bdfae66a91b1f166dc35059ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector of instantiated reports based on this descriptor. <br /></td></tr>
<tr class="separator:ad29c89bdfae66a91b1f166dc35059ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f30293a05dfa97fd9e1d1217e677791"><td class="memItemLeft" align="right" valign="top"><a id="a9f30293a05dfa97fd9e1d1217e677791"></a>
std::vector&lt; Report * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a9f30293a05dfa97fd9e1d1217e677791">getPendingInstantiations</a> () const</td></tr>
<tr class="memdesc:a9f30293a05dfa97fd9e1d1217e677791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of reports that have not been instantiated yet, but will be when this report descriptor's start trigger fires. <br /></td></tr>
<tr class="separator:a9f30293a05dfa97fd9e1d1217e677791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1227288f6e64b44c622a944c015af20"><td class="memItemLeft" align="right" valign="top"><a id="af1227288f6e64b44c622a944c015af20"></a>
std::vector&lt; Report * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#af1227288f6e64b44c622a944c015af20">getAllInstantiations</a> () const</td></tr>
<tr class="memdesc:af1227288f6e64b44c622a944c015af20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all report instantiations, including those already instantiated (no report start trigger) and pending report instantiations (they have a start trigger, and it hasn't fired yet) <br /></td></tr>
<tr class="separator:af1227288f6e64b44c622a944c015af20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125c9fbf17200f13f95f7c11cf357697"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a125c9fbf17200f13f95f7c11cf357697">writeOutput</a> (std::ostream *out=nullptr)</td></tr>
<tr class="memdesc:a125c9fbf17200f13f95f7c11cf357697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves all of the instantiations whose formatters do not support 'update' to their respective destinations. Returns the number of reports written in full in this call.  <a href="classsparta_1_1app_1_1ReportDescriptor.html#a125c9fbf17200f13f95f7c11cf357697">More...</a><br /></td></tr>
<tr class="separator:a125c9fbf17200f13f95f7c11cf357697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f4ff444a371bea92fe9d63270fd630"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#af8f4ff444a371bea92fe9d63270fd630">updateOutput</a> (std::ostream *out=nullptr)</td></tr>
<tr class="memdesc:af8f4ff444a371bea92fe9d63270fd630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates all of the instantiations whose formatters support 'update', possibly by writing to the destinations. Returns the number of reports updated in this call.  <a href="classsparta_1_1app_1_1ReportDescriptor.html#af8f4ff444a371bea92fe9d63270fd630">More...</a><br /></td></tr>
<tr class="separator:af8f4ff444a371bea92fe9d63270fd630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34e787f5de3a812876bec2f27048b9b"><td class="memItemLeft" align="right" valign="top"><a id="aa34e787f5de3a812876bec2f27048b9b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#aa34e787f5de3a812876bec2f27048b9b">skipOutput</a> ()</td></tr>
<tr class="memdesc:aa34e787f5de3a812876bec2f27048b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let the descriptor know to skip over one update of data. <br /></td></tr>
<tr class="separator:aa34e787f5de3a812876bec2f27048b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aee15b1572893dd6fada2161b285e12"><td class="memItemLeft" align="right" valign="top"><a id="a2aee15b1572893dd6fada2161b285e12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a2aee15b1572893dd6fada2161b285e12">capUpdatesToOncePerTick</a> (const <a class="el" href="classsparta_1_1Scheduler.html">Scheduler</a> *scheduler)</td></tr>
<tr class="memdesc:a2aee15b1572893dd6fada2161b285e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct this descriptor to automatically ignore any "duplicate" updates that occur at the exact same tick. <br /></td></tr>
<tr class="separator:a2aee15b1572893dd6fada2161b285e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74b0fea1c016f86ed86cf4ce04bca7b"><td class="memItemLeft" align="right" valign="top"><a id="af74b0fea1c016f86ed86cf4ce04bca7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#af74b0fea1c016f86ed86cf4ce04bca7b">setSkippedAnnotator</a> (std::shared_ptr&lt; sparta::trigger::SkippedAnnotatorBase &gt; annotator)</td></tr>
<tr class="memdesc:af74b0fea1c016f86ed86cf4ce04bca7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give this descriptor a specific annotator subclass for printing skipped update information to reports. <br /></td></tr>
<tr class="separator:af74b0fea1c016f86ed86cf4ce04bca7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c42e05576874d93dfedd3902ab197d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a7c42e05576874d93dfedd3902ab197d0">clearDestinationFiles</a> (const <a class="el" href="classsparta_1_1app_1_1Simulation.html">Simulation</a> &amp;sim)</td></tr>
<tr class="memdesc:a7c42e05576874d93dfedd3902ab197d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all destination files that will be filled with instances of this report descriptor.  <a href="classsparta_1_1app_1_1ReportDescriptor.html#a7c42e05576874d93dfedd3902ab197d0">More...</a><br /></td></tr>
<tr class="separator:a7c42e05576874d93dfedd3902ab197d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a44ddd40f42956fa3c8b17bdbe3212f"><td class="memItemLeft" align="right" valign="top"><a id="a0a44ddd40f42956fa3c8b17bdbe3212f"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a0a44ddd40f42956fa3c8b17bdbe3212f">getUsageCount</a> () const</td></tr>
<tr class="memdesc:a0a44ddd40f42956fa3c8b17bdbe3212f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the usage count (incremented by addInstantiation) <br /></td></tr>
<tr class="separator:a0a44ddd40f42956fa3c8b17bdbe3212f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7944535828cf3e12837cf9d995dbfa"><td class="memItemLeft" align="right" valign="top"><a id="a4b7944535828cf3e12837cf9d995dbfa"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a4b7944535828cf3e12837cf9d995dbfa">getNumWrites</a> () const</td></tr>
<tr class="memdesc:a4b7944535828cf3e12837cf9d995dbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of writes done on this report descriptor's instantiated report formatters. <br /></td></tr>
<tr class="separator:a4b7944535828cf3e12837cf9d995dbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3896475b25a61de98e2556dbaea391"><td class="memItemLeft" align="right" valign="top"><a id="a4d3896475b25a61de98e2556dbaea391"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a4d3896475b25a61de98e2556dbaea391">getNumUpdates</a> () const</td></tr>
<tr class="memdesc:a4d3896475b25a61de98e2556dbaea391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of updates done on this report descriptor's instantiated report formatters. <br /></td></tr>
<tr class="separator:a4d3896475b25a61de98e2556dbaea391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11267995eb9d44df01817e3a1fa9a8a1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a11267995eb9d44df01817e3a1fa9a8a1">computeFilename</a> (const Report *r, const std::string &amp;sim_name, uint32_t idx) const</td></tr>
<tr class="memdesc:a11267995eb9d44df01817e3a1fa9a8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the filename to which this reportdescriptor will be saved using any necessary variables in the name based on its instantiation context and <em>sim_name</em>.  <a href="classsparta_1_1app_1_1ReportDescriptor.html#a11267995eb9d44df01817e3a1fa9a8a1">More...</a><br /></td></tr>
<tr class="separator:a11267995eb9d44df01817e3a1fa9a8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa013eca6b03cc8bbf8723bef62f4cae7"><td class="memItemLeft" align="right" valign="top"><a id="aa013eca6b03cc8bbf8723bef62f4cae7"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#aa013eca6b03cc8bbf8723bef62f4cae7">isValidFormatName</a> (const std::string &amp;<a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a0bd8e6b7897f742f0bafe62bba704ae1">format</a>)</td></tr>
<tr class="memdesc:aa013eca6b03cc8bbf8723bef62f4cae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if format is a valid name for formatter. This allows the command line parser to disregard tokens at the end of a report command which are not formatters and instead interpret them as positional arguments. <br /></td></tr>
<tr class="separator:aa013eca6b03cc8bbf8723bef62f4cae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a73cf59e1b66fd12964a2a9289e7aef03"><td class="memItemLeft" align="right" valign="top"><a id="a73cf59e1b66fd12964a2a9289e7aef03"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a73cf59e1b66fd12964a2a9289e7aef03">loc_pattern</a></td></tr>
<tr class="memdesc:a73cf59e1b66fd12964a2a9289e7aef03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node location string (pattern) on which report should be generated. Typically "" or top. <br /></td></tr>
<tr class="separator:a73cf59e1b66fd12964a2a9289e7aef03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1f24a42deda732c5c19ec8613b3c11"><td class="memItemLeft" align="right" valign="top"><a id="aaf1f24a42deda732c5c19ec8613b3c11"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#aaf1f24a42deda732c5c19ec8613b3c11">def_file</a></td></tr>
<tr class="memdesc:aaf1f24a42deda732c5c19ec8613b3c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filename of report definition. If '@', auto generates reports with all counters and stats of loc_pattern. <br /></td></tr>
<tr class="separator:aaf1f24a42deda732c5c19ec8613b3c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4776e5209c79e446743a0415812e607d"><td class="memItemLeft" align="right" valign="top"><a id="a4776e5209c79e446743a0415812e607d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a4776e5209c79e446743a0415812e607d">dest_file</a></td></tr>
<tr class="memdesc:a4776e5209c79e446743a0415812e607d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destination filename to which report will be written. Later this will represent other types of destination besides files. <br /></td></tr>
<tr class="separator:a4776e5209c79e446743a0415812e607d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd8e6b7897f742f0bafe62bba704ae1"><td class="memItemLeft" align="right" valign="top"><a id="a0bd8e6b7897f742f0bafe62bba704ae1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a0bd8e6b7897f742f0bafe62bba704ae1">format</a></td></tr>
<tr class="memdesc:a0bd8e6b7897f742f0bafe62bba704ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional formatting string (how to write to the file). This is converted to lower-case at construction. <br /></td></tr>
<tr class="separator:a0bd8e6b7897f742f0bafe62bba704ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9578a883f014cf13cb7dba9d63d41906"><td class="memItemLeft" align="right" valign="top"><a id="a9578a883f014cf13cb7dba9d63d41906"></a>
NamedExtensions&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a9578a883f014cf13cb7dba9d63d41906">extensions_</a></td></tr>
<tr class="memdesc:a9578a883f014cf13cb7dba9d63d41906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key-value extensions used by parsers to bind opaque report configurations to descriptors. <br /></td></tr>
<tr class="separator:a9578a883f014cf13cb7dba9d63d41906"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5fcddf4cb2cdcc1b26359834378a9b09"><td class="memItemLeft" align="right" valign="top"><a id="a5fcddf4cb2cdcc1b26359834378a9b09"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html#a5fcddf4cb2cdcc1b26359834378a9b09">GLOBAL_KEYWORD</a></td></tr>
<tr class="memdesc:a5fcddf4cb2cdcc1b26359834378a9b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global search scope node keyword for report locations. <br /></td></tr>
<tr class="separator:a5fcddf4cb2cdcc1b26359834378a9b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad22f8c70a5a626222d4af5a4105a63f3"><td class="memItemLeft" align="right" valign="top"><a id="ad22f8c70a5a626222d4af5a4105a63f3"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ReportDescriptorCollection</b></td></tr>
<tr class="separator:ad22f8c70a5a626222d4af5a4105a63f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Describes one or more report to instantiate. </p>

<p class="definition">Definition at line <a class="el" href="ReportDescriptor_8hpp_source.html#l00087">87</a> of file <a class="el" href="ReportDescriptor_8hpp_source.html">ReportDescriptor.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7c321bc8c1d2ca925ff641e5aaba80f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c321bc8c1d2ca925ff641e5aaba80f4">&#9670;&nbsp;</a></span>ReportDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sparta::app::ReportDescriptor::ReportDescriptor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_loc_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_def_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_dest_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_format</em> = <code>&quot;text&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a report decsriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_loc_pattern</td><td>Location patern identifying 1 or more nodes on which to construct a report </td></tr>
    <tr><td class="paramname">_def_file</td><td>Report definition file path relative to current working directory. Note, this may also be '@' to generate reports which each contain all counters and stats in the subtree(s) of the node(s) described by _loc_pattern. </td></tr>
    <tr><td class="paramname">_dest_file</td><td>File to which these reports should be written. This may contain report name wildcards to identify output files based on replacements made in <em>_loc_pattern</em>. Output formatter is chosen by the file extension of this path unless explicitly set in <em>_format</em>. If sparta::utils::COUT_FILENAME, will write to stdout. If sparta::utils::CERR_FILENAME, will write to stderr. Note that A formatter which supports ostream writing must be chosen to support this or an exception will be thrown </td></tr>
    <tr><td class="paramname">_format</td><td>Optional explicit format specificier. Extensions allowed are all those defined in sparta::report::format::BaseFormatter::FACTORIES. If omitted, deduces the format based on _dest_file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if the _dest_file is 1 or 2 and the formatter chosen (by _format if specified or the secondarily _dest_file) is not an ostream formatter (is not a sparta::report::format::BaseOstreamFormatter). This is tested in construction so that no time is wasted on failure - as opposed to checkout formatters when finally writing reports </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6c25701cf3e7c2583657bed041c65d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c25701cf3e7c2583657bed041c65d68">&#9670;&nbsp;</a></span>addInstantiation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">report::format::BaseFormatter* sparta::app::ReportDescriptor::addInstantiation </td>
          <td>(</td>
          <td class="paramtype">Report *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1app_1_1Simulation.html">Simulation</a> *&#160;</td>
          <td class="paramname"><em>sim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>out</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracks a report instantiated based on this descriptor and allocates a new formatter for it. Later, these tracked reports can be iterated and saved to different destinations (or the same) depending on their order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Report to track. Caller maintains ownership of this. Must outlive this instance of <a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html" title="Describes one or more report to instantiate.">ReportDescriptor</a>. Must be fully populated because the formatter created by this fuction may be written to immediately </td></tr>
    <tr><td class="paramname">fmt</td><td>The output formatter associated with this report. Caller maintains ownership of this. Must outlive this instance of <a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html" title="Describes one or more report to instantiate.">ReportDescriptor</a> </td></tr>
    <tr><td class="paramname">out</td><td>Output stream to write actions to. If nullptr, no actions are written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated BaseFormatter. Caller is resposible for deallocation. Allocated through sparta::report::format::FormatterFactory::factory method which allocates using 'new'. This new formatter will read the input report and be initialized based on its content. The header of the report may be written to the formatter immediately </dd></dl>

</div>
</div>
<a id="a7c42e05576874d93dfedd3902ab197d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c42e05576874d93dfedd3902ab197d0">&#9670;&nbsp;</a></span>clearDestinationFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::ReportDescriptor::clearDestinationFiles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1app_1_1Simulation.html">Simulation</a> &amp;&#160;</td>
          <td class="paramname"><em>sim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all destination files that will be filled with instances of this report descriptor. </p>
<p>This is done at simulation startup so that reports are empty until written. After simulation, reports are appended to these files </p>

</div>
</div>
<a id="a11267995eb9d44df01817e3a1fa9a8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11267995eb9d44df01817e3a1fa9a8a1">&#9670;&nbsp;</a></span>computeFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string sparta::app::ReportDescriptor::computeFilename </td>
          <td>(</td>
          <td class="paramtype">const Report *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sim_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the filename to which this reportdescriptor will be saved using any necessary variables in the name based on its instantiation context and <em>sim_name</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Report whose filename should be computed. </td></tr>
    <tr><td class="paramname">idx</td><td>Index of the report in this <a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html" title="Describes one or more report to instantiate.">ReportDescriptor</a>'s instantiations This is required to fill in wildcards in the report name where multiple reports are generated from one descriptor. Each can have its own index in its name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>computeOutputFilename </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not attempt to open the filename </dd></dl>

</div>
</div>
<a id="a9bc5eeb893665f711a7fdc0d47603fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc5eeb893665f711a7fdc0d47603fce">&#9670;&nbsp;</a></span>configureAsyncNonTimeseriesReport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::ReportDescriptor::configureAsyncNonTimeseriesReport </td>
          <td>(</td>
          <td class="paramtype">simdb::AsyncTaskEval *&#160;</td>
          <td class="paramname"><em>task_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simdb::ObjectManager *&#160;</td>
          <td class="paramname"><em>sim_db</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch this descriptor's report generation from synchronous to asynchronous database persistence. This method is intended only for descriptors that have just one <em>non-timeseries</em> report format. </p>
<p>Call "isSingleNonTimeseriesReport()" first before calling this method to be sure, otherwise this method may throw. </p>

</div>
</div>
<a id="a4accee4337e7e81e42bf88c7338a338d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4accee4337e7e81e42bf88c7338a338d">&#9670;&nbsp;</a></span>configureAsyncTimeseriesReport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::ReportDescriptor::configureAsyncTimeseriesReport </td>
          <td>(</td>
          <td class="paramtype">simdb::AsyncTaskEval *&#160;</td>
          <td class="paramname"><em>task_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simdb::ObjectManager *&#160;</td>
          <td class="paramname"><em>sim_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> &amp;&#160;</td>
          <td class="paramname"><em>root_clk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch this descriptor's timeseries report generation from synchronous .csv generation to asynchronous database persistence. </p>
<p>The task queue object passed in is the worker thread object, which is shared among all report descriptors in the simulation.</p>
<p>The simulation database passed in is the object with the actual connection to the physical database. This object is shared with the <a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">Simulation</a> class and other descriptors.</p>
<p>The <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">Scheduler</a> passed in is the one our simulation is running on, and the <a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">Clock</a> passed in is the simulation's root clock. Both of these objects are used in order to get the "current time" value at each report update (current cycle, simulated time, etc.) </p>

</div>
</div>
<a id="af8f4ff444a371bea92fe9d63270fd630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f4ff444a371bea92fe9d63270fd630">&#9670;&nbsp;</a></span>updateOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::app::ReportDescriptor::updateOutput </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>out</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates all of the instantiations whose formatters support 'update', possibly by writing to the destinations. Returns the number of reports updated in this call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Print reports being written to out unless nulltr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a125c9fbf17200f13f95f7c11cf357697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125c9fbf17200f13f95f7c11cf357697">&#9670;&nbsp;</a></span>writeOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::app::ReportDescriptor::writeOutput </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>out</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves all of the instantiations whose formatters do not support 'update' to their respective destinations. Returns the number of reports written in full in this call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Print reports being written to out unless nulltr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/sparta/sparta/app/<a class="el" href="ReportDescriptor_8hpp_source.html">ReportDescriptor.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li><li class="navelem"><a class="el" href="namespacesparta_1_1app.html">app</a></li><li class="navelem"><a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html">ReportDescriptor</a></li>
    <li class="footer">Generated on Fri Sep 25 2020 04:28:31 for The Sparta Modeling Framework by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
