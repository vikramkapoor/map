<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta::app::Simulation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classsparta_1_1app_1_1Simulation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classsparta_1_1app_1_1Simulation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sparta::app::Simulation Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Simulator which builds a sparta DeviceTree.  
 <a href="classsparta_1_1app_1_1Simulation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Simulation_8hpp_source.html">Simulation.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sparta::app::Simulation:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1app_1_1Simulation__inherit__graph.png" border="0" usemap="#asparta_1_1app_1_1Simulation_inherit__map" alt="Inheritance graph"/></div>
<map name="sparta_1_1app_1_1Simulation_inherit__map" id="asparta_1_1app_1_1Simulation_inherit__map">
<area shape="rect" title="Simulator which builds a sparta DeviceTree." alt="" coords="69,5,221,32"/>
<area shape="rect" href="classExampleSimulator.html" title="ExampleSimulator which builds the model and configures it." alt="" coords="5,80,132,107"/>
<area shape="rect" href="classSkeletonSimulator.html" title="SkeletonSimulator which builds the model and configures it." alt="" coords="157,80,285,107"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sparta::app::Simulation:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1app_1_1Simulation__coll__graph.png" border="0" usemap="#asparta_1_1app_1_1Simulation_coll__map" alt="Collaboration graph"/></div>
<map name="sparta_1_1app_1_1Simulation_coll__map" id="asparta_1_1app_1_1Simulation_coll__map">
<area shape="rect" title="Simulator which builds a sparta DeviceTree." alt="" coords="1160,236,1312,263"/>
<area shape="rect" href="classsparta_1_1app_1_1FeatureConfiguration.html" title="Collection of named feature values." alt="" coords="801,5,1012,32"/>
<area shape="rect" href="classsparta_1_1app_1_1ReportDescriptorCollection.html" title="This collection of ReportDescriptors is designed to never deallocate memory once it has been allocate..." alt="" coords="813,57,1001,98"/>
<area shape="rect" href="classsparta_1_1app_1_1SimulationConfiguration.html" title="Configuration applicator class that is used for configuring a simulator. Works in conjunction with sp..." alt="" coords="793,123,1020,149"/>
<area shape="rect" href="classsparta_1_1RootTreeNode.html" title="TreeNode which represents the root (&quot;top&quot;) of a device tree." alt="" coords="596,205,744,232"/>
<area shape="rect" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future." alt="" coords="845,236,968,263"/>
<area shape="rect" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item." alt="" coords="425,205,547,232"/>
<area shape="rect" href="classsparta_1_1ResourceContainer.html" title="PhasedObject which can hold 0 or 1 Resource pointers to an associatedresource. Contains logic for set..." alt="" coords="201,171,376,197"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html" title="Object having a specific phase in the sparta construction paradigm." alt="" coords="5,171,152,197"/>
<area shape="rect" href="classsparta_1_1ArchDataContainer.html" title="Container class for any number of ArchData pointers owned externally." alt="" coords="202,221,375,248"/>
<area shape="rect" href="classsparta_1_1app_1_1Backtrace.html" title="Backtrace printer. Registers a handler for certain fatal signals and dumps the backtrace if they occu..." alt="" coords="831,287,982,313"/>
<area shape="rect" href="classsparta_1_1ClockManager.html" title="Manages building a clock tree." alt="" coords="833,337,980,364"/>
<area shape="rect" href="classsparta_1_1log_1_1Tap.html" title="Logging Tap. Attach to a TreeNode to intercept logging messages from any NotificationSource nodes in ..." alt="" coords="852,388,961,415"/>
<area shape="rect" href="classsparta_1_1ResourceSet.html" title="Set of published ResourceFactories which can be referenced by name." alt="" coords="837,439,976,465"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation_1_1SimulationController.html">SimulationController</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used for simulation control callbacks. The callback conditions (trigger expressions) are specified in control YAML files.  <a href="classsparta_1_1app_1_1Simulation_1_1SimulationController.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2c1cbf112314f9a69927744a7855e18c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a2c1cbf112314f9a69927744a7855e18c">CounterSemantic</a> { <a class="el" href="classsparta_1_1app_1_1Simulation.html#a2c1cbf112314f9a69927744a7855e18ca6802d1020aafd2ec136d237bffb8c56b">CSEM_INSTRUCTIONS</a> = 0
 }</td></tr>
<tr class="memdesc:a2c1cbf112314f9a69927744a7855e18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of semantics attached to certain counters. It is the responsibility of subclasses to implement findSemanticCounter such taht it can satisfy requests for counters having these semantics.  <a href="classsparta_1_1app_1_1Simulation.html#a2c1cbf112314f9a69927744a7855e18c">More...</a><br /></td></tr>
<tr class="separator:a2c1cbf112314f9a69927744a7855e18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7a390621aca161e2b7dbb66fd95dc937"><td class="memItemLeft" align="right" valign="top"><a id="a7a390621aca161e2b7dbb66fd95dc937"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a7a390621aca161e2b7dbb66fd95dc937">Simulation</a> ()=delete</td></tr>
<tr class="memdesc:a7a390621aca161e2b7dbb66fd95dc937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not default-constructable. <br /></td></tr>
<tr class="separator:a7a390621aca161e2b7dbb66fd95dc937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909dccfa4b54d14c1dddae5b4f91bab4"><td class="memItemLeft" align="right" valign="top"><a id="a909dccfa4b54d14c1dddae5b4f91bab4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a909dccfa4b54d14c1dddae5b4f91bab4">Simulation</a> (const <a class="el" href="classsparta_1_1app_1_1Simulation.html">Simulation</a> &amp;)=delete</td></tr>
<tr class="memdesc:a909dccfa4b54d14c1dddae5b4f91bab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not copy-constructable. <br /></td></tr>
<tr class="separator:a909dccfa4b54d14c1dddae5b4f91bab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd53645b21eb4bdd6b3002056a5ee6a"><td class="memItemLeft" align="right" valign="top"><a id="afdd53645b21eb4bdd6b3002056a5ee6a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#afdd53645b21eb4bdd6b3002056a5ee6a">Simulation</a> (<a class="el" href="classsparta_1_1app_1_1Simulation.html">Simulation</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:afdd53645b21eb4bdd6b3002056a5ee6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not move-constructable. <br /></td></tr>
<tr class="separator:afdd53645b21eb4bdd6b3002056a5ee6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17c48eaf2a22440cfd3214a19a939ea"><td class="memItemLeft" align="right" valign="top"><a id="ac17c48eaf2a22440cfd3214a19a939ea"></a>
<a class="el" href="classsparta_1_1app_1_1Simulation.html">Simulation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#ac17c48eaf2a22440cfd3214a19a939ea">operator=</a> (const <a class="el" href="classsparta_1_1app_1_1Simulation.html">Simulation</a> &amp;)=delete</td></tr>
<tr class="memdesc:ac17c48eaf2a22440cfd3214a19a939ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not assignable. <br /></td></tr>
<tr class="separator:ac17c48eaf2a22440cfd3214a19a939ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7502b73eb6552794bb61eda46bdea821"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a7502b73eb6552794bb61eda46bdea821">Simulation</a> (const std::string &amp;sim_name, <a class="el" href="classsparta_1_1Scheduler.html">Scheduler</a> *scheduler)</td></tr>
<tr class="memdesc:a7502b73eb6552794bb61eda46bdea821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deferred configuration constructor. Subsequent call to configure must be made before building/configuring/finalizing.  <a href="classsparta_1_1app_1_1Simulation.html#a7502b73eb6552794bb61eda46bdea821">More...</a><br /></td></tr>
<tr class="separator:a7502b73eb6552794bb61eda46bdea821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2930aba72b49107eed4356f0865d7ebf"><td class="memItemLeft" align="right" valign="top"><a id="a2930aba72b49107eed4356f0865d7ebf"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a2930aba72b49107eed4356f0865d7ebf">~Simulation</a> ()</td></tr>
<tr class="memdesc:a2930aba72b49107eed4356f0865d7ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:a2930aba72b49107eed4356f0865d7ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac09ce6f13aafb6dfb83780398bb6e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a6ac09ce6f13aafb6dfb83780398bb6e3">setFeatureConfig</a> (const <a class="el" href="classsparta_1_1app_1_1FeatureConfiguration.html">FeatureConfiguration</a> *feature_config)</td></tr>
<tr class="memdesc:a6ac09ce6f13aafb6dfb83780398bb6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a collection of feature name-value pairs.  <a href="classsparta_1_1app_1_1Simulation.html#a6ac09ce6f13aafb6dfb83780398bb6e3">More...</a><br /></td></tr>
<tr class="separator:a6ac09ce6f13aafb6dfb83780398bb6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7055b63e8e5ae50695a3556ee09560"><td class="memItemLeft" align="right" valign="top">simdb::DatabaseRoot *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a3e7055b63e8e5ae50695a3556ee09560">getDatabaseRoot</a> () const</td></tr>
<tr class="memdesc:a3e7055b63e8e5ae50695a3556ee09560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the database root for this simulation.  <a href="classsparta_1_1app_1_1Simulation.html#a3e7055b63e8e5ae50695a3556ee09560">More...</a><br /></td></tr>
<tr class="separator:a3e7055b63e8e5ae50695a3556ee09560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493558565fcf6e7916f9a64d640075c4"><td class="memItemLeft" align="right" valign="top"><a id="a493558565fcf6e7916f9a64d640075c4"></a>
const DatabaseAccessor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a493558565fcf6e7916f9a64d640075c4">getSimulationDatabaseAccessor</a> () const</td></tr>
<tr class="memdesc:a493558565fcf6e7916f9a64d640075c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">There is a 1-to-1 mapping between a running simulation and the database it is using. Some components in the simulator may have database access, while others are not intended to use the database. This is controlled via command line arguments, and the simulation's DatabaseAccessor knows which components are DB- enabled, and which are not. <br /></td></tr>
<tr class="separator:a493558565fcf6e7916f9a64d640075c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894a3af52b6ae904b529420c78f2873c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a894a3af52b6ae904b529420c78f2873c">configure</a> (const int argc, char **argv, <a class="el" href="classsparta_1_1app_1_1SimulationConfiguration.html">SimulationConfiguration</a> *configuration, const bool use_pyshell=false)</td></tr>
<tr class="memdesc:a894a3af52b6ae904b529420c78f2873c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the simulator after construction. Necessary only when using the simple constructor.  <a href="classsparta_1_1app_1_1Simulation.html#a894a3af52b6ae904b529420c78f2873c">More...</a><br /></td></tr>
<tr class="separator:a894a3af52b6ae904b529420c78f2873c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00fc8fabf896719884117a30f9062d06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a00fc8fabf896719884117a30f9062d06">addReport</a> (const <a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html">ReportDescriptor</a> &amp;rep)</td></tr>
<tr class="memdesc:a00fc8fabf896719884117a30f9062d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a report.  <a href="classsparta_1_1app_1_1Simulation.html#a00fc8fabf896719884117a30f9062d06">More...</a><br /></td></tr>
<tr class="separator:a00fc8fabf896719884117a30f9062d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fef813ad97b712856fa4e1f91b193d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a55fef813ad97b712856fa4e1f91b193d">installTaps</a> (const log::TapDescVec &amp;taps)</td></tr>
<tr class="memdesc:a55fef813ad97b712856fa4e1f91b193d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new taps the the simulation immediately IF possible.  <a href="classsparta_1_1app_1_1Simulation.html#a55fef813ad97b712856fa4e1f91b193d">More...</a><br /></td></tr>
<tr class="separator:a55fef813ad97b712856fa4e1f91b193d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcee1dc30a0f93c2c55379cb69227f7"><td class="memItemLeft" align="right" valign="top"><a id="addcee1dc30a0f93c2c55379cb69227f7"></a>
<a class="el" href="classsparta_1_1RootTreeNode.html">sparta::RootTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#addcee1dc30a0f93c2c55379cb69227f7">getRoot</a> () noexcept</td></tr>
<tr class="memdesc:addcee1dc30a0f93c2c55379cb69227f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tree root. <br /></td></tr>
<tr class="separator:addcee1dc30a0f93c2c55379cb69227f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c333425d7affb6708847f4487aac4a8"><td class="memItemLeft" align="right" valign="top"><a id="a2c333425d7affb6708847f4487aac4a8"></a>
<a class="el" href="classsparta_1_1app_1_1MetaTreeNode.html">sparta::app::MetaTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a2c333425d7affb6708847f4487aac4a8">getMetaParamRoot</a> () const noexcept</td></tr>
<tr class="memdesc:a2c333425d7affb6708847f4487aac4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Meta <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> root. <br /></td></tr>
<tr class="separator:a2c333425d7affb6708847f4487aac4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db5385c6762e5fe5e4fc5df01167388"><td class="memItemLeft" align="right" valign="top"><a id="a2db5385c6762e5fe5e4fc5df01167388"></a>
const <a class="el" href="classsparta_1_1RootTreeNode.html">sparta::RootTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a2db5385c6762e5fe5e4fc5df01167388">getRoot</a> () const noexcept</td></tr>
<tr class="memdesc:a2db5385c6762e5fe5e4fc5df01167388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tree root (const) <br /></td></tr>
<tr class="separator:a2db5385c6762e5fe5e4fc5df01167388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2f91d8d780ddf40490d611498efc8f"><td class="memItemLeft" align="right" valign="top"><a id="ace2f91d8d780ddf40490d611498efc8f"></a>
<a class="el" href="classsparta_1_1Scheduler.html">sparta::Scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#ace2f91d8d780ddf40490d611498efc8f">getScheduler</a> ()</td></tr>
<tr class="memdesc:ace2f91d8d780ddf40490d611498efc8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the simulation's scheduler. <br /></td></tr>
<tr class="separator:ace2f91d8d780ddf40490d611498efc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad153d0851bb16f3fc6dacb2bbdd0745"><td class="memItemLeft" align="right" valign="top"><a id="aad153d0851bb16f3fc6dacb2bbdd0745"></a>
const <a class="el" href="classsparta_1_1Scheduler.html">sparta::Scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#aad153d0851bb16f3fc6dacb2bbdd0745">getScheduler</a> () const</td></tr>
<tr class="memdesc:aad153d0851bb16f3fc6dacb2bbdd0745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the simulation's scheduler. <br /></td></tr>
<tr class="separator:aad153d0851bb16f3fc6dacb2bbdd0745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572d907699cd95ff73ec82c271e6b9da"><td class="memItemLeft" align="right" valign="top"><a id="a572d907699cd95ff73ec82c271e6b9da"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a572d907699cd95ff73ec82c271e6b9da">usingFinalConfig</a> () const</td></tr>
<tr class="memdesc:a572d907699cd95ff73ec82c271e6b9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the simulator was configured using a final configuration option, likely via the &ndash;read-final-config cml option. <br /></td></tr>
<tr class="separator:a572d907699cd95ff73ec82c271e6b9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ca4cbbb22bb5cfbd8c3838179796a5"><td class="memItemLeft" align="right" valign="top"><a id="a21ca4cbbb22bb5cfbd8c3838179796a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a21ca4cbbb22bb5cfbd8c3838179796a5">readyToRun</a> () const</td></tr>
<tr class="memdesc:a21ca4cbbb22bb5cfbd8c3838179796a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the framework ready to run. <br /></td></tr>
<tr class="separator:a21ca4cbbb22bb5cfbd8c3838179796a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4665397a527c15c17fe90b31280ccd"><td class="memItemLeft" align="right" valign="top"><a id="a9d4665397a527c15c17fe90b31280ccd"></a>
<a class="el" href="classsparta_1_1Clock.html">sparta::Clock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a9d4665397a527c15c17fe90b31280ccd">getRootClock</a> () noexcept</td></tr>
<tr class="memdesc:a9d4665397a527c15c17fe90b31280ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the root clock. <br /></td></tr>
<tr class="separator:a9d4665397a527c15c17fe90b31280ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48d86cd7c44b62defbc97be9d417529"><td class="memItemLeft" align="right" valign="top"><a id="aa48d86cd7c44b62defbc97be9d417529"></a>
const <a class="el" href="classsparta_1_1Clock.html">sparta::Clock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#aa48d86cd7c44b62defbc97be9d417529">getRootClock</a> () const noexcept</td></tr>
<tr class="memdesc:aa48d86cd7c44b62defbc97be9d417529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the root clock (const) <br /></td></tr>
<tr class="separator:aa48d86cd7c44b62defbc97be9d417529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835c1baf8a21fc86c51b278ee558db9d"><td class="memItemLeft" align="right" valign="top"><a id="a835c1baf8a21fc86c51b278ee558db9d"></a>
<a class="el" href="classsparta_1_1ClockManager.html">sparta::ClockManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a835c1baf8a21fc86c51b278ee558db9d">getClockManager</a> () noexcept</td></tr>
<tr class="memdesc:a835c1baf8a21fc86c51b278ee558db9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the clock manager. <br /></td></tr>
<tr class="separator:a835c1baf8a21fc86c51b278ee558db9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00d74388f3b136c3d411cc2c88234ed"><td class="memItemLeft" align="right" valign="top"><a id="ac00d74388f3b136c3d411cc2c88234ed"></a>
<a class="el" href="classsparta_1_1ResourceSet.html">sparta::ResourceSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#ac00d74388f3b136c3d411cc2c88234ed">getResourceSet</a> () noexcept</td></tr>
<tr class="memdesc:ac00d74388f3b136c3d411cc2c88234ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the resource set for this <a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">Simulation</a>. <br /></td></tr>
<tr class="separator:ac00d74388f3b136c3d411cc2c88234ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c21f9132118ab5d66e84de7d23db1a1"><td class="memItemLeft" align="right" valign="top"><a id="a8c21f9132118ab5d66e84de7d23db1a1"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a8c21f9132118ab5d66e84de7d23db1a1">getSimName</a> () const noexcept</td></tr>
<tr class="memdesc:a8c21f9132118ab5d66e84de7d23db1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this simulator's name. <br /></td></tr>
<tr class="separator:a8c21f9132118ab5d66e84de7d23db1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d23e6458ed36eb46b8c00e8f6a6c644"><td class="memItemLeft" align="right" valign="top"><a id="a8d23e6458ed36eb46b8c00e8f6a6c644"></a>
<a class="el" href="classsparta_1_1app_1_1SimulationConfiguration.html">SimulationConfiguration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a8d23e6458ed36eb46b8c00e8f6a6c644">getSimulationConfiguration</a> () const</td></tr>
<tr class="memdesc:a8d23e6458ed36eb46b8c00e8f6a6c644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this simulator's configuration. <br /></td></tr>
<tr class="separator:a8d23e6458ed36eb46b8c00e8f6a6c644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1d5ac31339da93b415bb815cf42d3c"><td class="memItemLeft" align="right" valign="top"><a id="a6a1d5ac31339da93b415bb815cf42d3c"></a>
const <a class="el" href="classsparta_1_1app_1_1FeatureConfiguration.html">FeatureConfiguration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a6a1d5ac31339da93b415bb815cf42d3c">getFeatureConfiguration</a> () const</td></tr>
<tr class="memdesc:a6a1d5ac31339da93b415bb815cf42d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this simulator's feature configuration. <br /></td></tr>
<tr class="separator:a6a1d5ac31339da93b415bb815cf42d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ca66d805e7c64ff6c72e193ff10850"><td class="memItemLeft" align="right" valign="top"><a id="a01ca66d805e7c64ff6c72e193ff10850"></a>
<a class="el" href="classsparta_1_1app_1_1ReportConfiguration.html">ReportConfiguration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a01ca66d805e7c64ff6c72e193ff10850">getReportConfiguration</a> () const</td></tr>
<tr class="memdesc:a01ca66d805e7c64ff6c72e193ff10850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this simulator's report configuration. <br /></td></tr>
<tr class="separator:a01ca66d805e7c64ff6c72e193ff10850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319e9c4e7418f8f953e1a527b4feff8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a319e9c4e7418f8f953e1a527b4feff8a">buildTree</a> ()</td></tr>
<tr class="memdesc:a319e9c4e7418f8f953e1a527b4feff8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds hard-coded device tree.  <a href="classsparta_1_1app_1_1Simulation.html#a319e9c4e7418f8f953e1a527b4feff8a">More...</a><br /></td></tr>
<tr class="separator:a319e9c4e7418f8f953e1a527b4feff8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a0e00d7f5998fec76bb62061a475ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a54a0e00d7f5998fec76bb62061a475ed">configureTree</a> ()</td></tr>
<tr class="memdesc:a54a0e00d7f5998fec76bb62061a475ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the tree with some node-local config files, params, and node-specific parameters.  <a href="classsparta_1_1app_1_1Simulation.html#a54a0e00d7f5998fec76bb62061a475ed">More...</a><br /></td></tr>
<tr class="separator:a54a0e00d7f5998fec76bb62061a475ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200bdd31a21e24a242770fcb8e7fff5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a200bdd31a21e24a242770fcb8e7fff5f">finalizeTree</a> ()</td></tr>
<tr class="memdesc:a200bdd31a21e24a242770fcb8e7fff5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes the device tree.  <a href="classsparta_1_1app_1_1Simulation.html#a200bdd31a21e24a242770fcb8e7fff5f">More...</a><br /></td></tr>
<tr class="separator:a200bdd31a21e24a242770fcb8e7fff5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ede64ec543df1bb56a71618fe82757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a18ede64ec543df1bb56a71618fe82757">finalizeFramework</a> ()</td></tr>
<tr class="memdesc:a18ede64ec543df1bb56a71618fe82757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize framework before running.  <a href="classsparta_1_1app_1_1Simulation.html#a18ede64ec543df1bb56a71618fe82757">More...</a><br /></td></tr>
<tr class="separator:a18ede64ec543df1bb56a71618fe82757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815cee822b7ca07fd569eae1f240ab07"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a815cee822b7ca07fd569eae1f240ab07">run</a> (uint64_t run_time)</td></tr>
<tr class="memdesc:a815cee822b7ca07fd569eae1f240ab07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run for specified "time" or less.  <a href="classsparta_1_1app_1_1Simulation.html#a815cee822b7ca07fd569eae1f240ab07">More...</a><br /></td></tr>
<tr class="separator:a815cee822b7ca07fd569eae1f240ab07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6aadfc529bfff578ff4ec17c032e83"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#aae6aadfc529bfff578ff4ec17c032e83">runRaw</a> (uint64_t run_time)</td></tr>
<tr class="memdesc:aae6aadfc529bfff578ff4ec17c032e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the simulation for a limited run time, returning when done.  <a href="classsparta_1_1app_1_1Simulation.html#aae6aadfc529bfff578ff4ec17c032e83">More...</a><br /></td></tr>
<tr class="separator:aae6aadfc529bfff578ff4ec17c032e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e53f536fa3ab32e66dbb67242569f29"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a9e53f536fa3ab32e66dbb67242569f29">asyncStop</a> ()</td></tr>
<tr class="memdesc:a9e53f536fa3ab32e66dbb67242569f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously stop the run.  <a href="classsparta_1_1app_1_1Simulation.html#a9e53f536fa3ab32e66dbb67242569f29">More...</a><br /></td></tr>
<tr class="separator:a9e53f536fa3ab32e66dbb67242569f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f4d6092177b67c9bf1f83cf9ed39d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a51f4d6092177b67c9bf1f83cf9ed39d9">dumpDebugContentIfAllowed</a> (std::exception_ptr eptr, bool forcec=false) noexcept</td></tr>
<tr class="memdesc:a51f4d6092177b67c9bf1f83cf9ed39d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if debug content needs to be dumped and dump if so. Uses dumpDebugContent to dump.  <a href="classsparta_1_1app_1_1Simulation.html#a51f4d6092177b67c9bf1f83cf9ed39d9">More...</a><br /></td></tr>
<tr class="separator:a51f4d6092177b67c9bf1f83cf9ed39d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe04ef09fd2d1bd1f5f81d7afe16d23"><td class="memItemLeft" align="right" valign="top"><a id="a1fe04ef09fd2d1bd1f5f81d7afe16d23"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a1fe04ef09fd2d1bd1f5f81d7afe16d23">saveReports</a> ()</td></tr>
<tr class="memdesc:a1fe04ef09fd2d1bd1f5f81d7afe16d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes all reports to their respective files. <br /></td></tr>
<tr class="separator:a1fe04ef09fd2d1bd1f5f81d7afe16d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affeacc60dab7f5302615e8341d24f0b8"><td class="memItemLeft" align="right" valign="top"><a id="affeacc60dab7f5302615e8341d24f0b8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#affeacc60dab7f5302615e8341d24f0b8">postProcessingLastCall</a> ()</td></tr>
<tr class="memdesc:affeacc60dab7f5302615e8341d24f0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">After <a class="el" href="classsparta_1_1app_1_1CommandLineSimulator.html" title="Command line simulator front-end class with argument parsing Works in conjunction with sparta::app::S...">CommandLineSimulator</a> runs the simulation and calls all post-processing APIs, this method will be called. It is the only thing left before our destructor gets called. Do any last- minute final wrap up work if needed in this method. <br /></td></tr>
<tr class="separator:affeacc60dab7f5302615e8341d24f0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbdbeb54718f1a0376d3f51593a23adc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1CounterBase.html">CounterBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#acbdbeb54718f1a0376d3f51593a23adc">findSemanticCounter</a> (<a class="el" href="classsparta_1_1app_1_1Simulation.html#a2c1cbf112314f9a69927744a7855e18c">CounterSemantic</a> sem) const</td></tr>
<tr class="memdesc:acbdbeb54718f1a0376d3f51593a23adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a counter by its semantic (if such a counter exists).  <a href="classsparta_1_1app_1_1Simulation.html#acbdbeb54718f1a0376d3f51593a23adc">More...</a><br /></td></tr>
<tr class="separator:acbdbeb54718f1a0376d3f51593a23adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3caea12cfc6795d43a222800b7c149"><td class="memItemLeft" align="right" valign="top"><a id="a2c3caea12cfc6795d43a222800b7c149"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a2c3caea12cfc6795d43a222800b7c149">numFired</a> ()</td></tr>
<tr class="memdesc:a2c3caea12cfc6795d43a222800b7c149"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of events fired on the scheduler during simulation. <br /></td></tr>
<tr class="separator:a2c3caea12cfc6795d43a222800b7c149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821da0eaa32f1586200513ae75f495ac"><td class="memItemLeft" align="right" valign="top"><a id="a821da0eaa32f1586200513ae75f495ac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a821da0eaa32f1586200513ae75f495ac">enablePostRunValidation</a> ()</td></tr>
<tr class="memdesc:a821da0eaa32f1586200513ae75f495ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable post-run validation explicity. <br /></td></tr>
<tr class="separator:a821da0eaa32f1586200513ae75f495ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9974d5e8d332f67402a1a8645e65c015"><td class="memItemLeft" align="right" valign="top"><a id="a9974d5e8d332f67402a1a8645e65c015"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a9974d5e8d332f67402a1a8645e65c015">getPipelineCollectionPrefix</a> () const</td></tr>
<tr class="memdesc:a9974d5e8d332f67402a1a8645e65c015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pipeline collection path. <br /></td></tr>
<tr class="separator:a9974d5e8d332f67402a1a8645e65c015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b99477fa7a93af2839f755bfc9eb4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a81b99477fa7a93af2839f755bfc9eb4b">usingPyshell</a> () const</td></tr>
<tr class="memdesc:a81b99477fa7a93af2839f755bfc9eb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Was this simulation configured with a Python shell?  <a href="classsparta_1_1app_1_1Simulation.html#a81b99477fa7a93af2839f755bfc9eb4b">More...</a><br /></td></tr>
<tr class="separator:a81b99477fa7a93af2839f755bfc9eb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54f06ff96e9de8f6cfdda48bc6f72d1"><td class="memItemLeft" align="right" valign="top">virtual sparta::control::TemporaryRunControl *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#aa54f06ff96e9de8f6cfdda48bc6f72d1">getRunControlInterface</a> ()</td></tr>
<tr class="memdesc:aa54f06ff96e9de8f6cfdda48bc6f72d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the run control interface for this simulation. This must exist for the lifetime of this simulation.  <a href="classsparta_1_1app_1_1Simulation.html#aa54f06ff96e9de8f6cfdda48bc6f72d1">More...</a><br /></td></tr>
<tr class="separator:aa54f06ff96e9de8f6cfdda48bc6f72d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a5f772032be533a68e73d37b721472"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#ab5a5f772032be533a68e73d37b721472">dumpMetaParameterTable</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ab5a5f772032be533a68e73d37b721472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write meta-data tree parameters to given ostream.  <a href="classsparta_1_1app_1_1Simulation.html#ab5a5f772032be533a68e73d37b721472">More...</a><br /></td></tr>
<tr class="separator:ab5a5f772032be533a68e73d37b721472"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9c40c1627781bfdf3762e5f204216618"><td class="memItemLeft" align="right" valign="top"><a id="a9c40c1627781bfdf3762e5f204216618"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a9c40c1627781bfdf3762e5f204216618">setSimulationController_</a> (std::shared_ptr&lt; <a class="el" href="classsparta_1_1app_1_1Simulation_1_1SimulationController.html">SimulationController</a> &gt; controller)</td></tr>
<tr class="memdesc:a9c40c1627781bfdf3762e5f204216618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a controller to handle custom simulation events. <br /></td></tr>
<tr class="separator:a9c40c1627781bfdf3762e5f204216618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ac1314cb7c785074b0477dbea40526"><td class="memItemLeft" align="right" valign="top"><a id="a19ac1314cb7c785074b0477dbea40526"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a19ac1314cb7c785074b0477dbea40526">pause_</a> ()</td></tr>
<tr class="memdesc:a19ac1314cb7c785074b0477dbea40526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggered simulation pause callback. <br /></td></tr>
<tr class="separator:a19ac1314cb7c785074b0477dbea40526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc0fd8c5371215c7c403aa9b1517dd6"><td class="memItemLeft" align="right" valign="top"><a id="a8cc0fd8c5371215c7c403aa9b1517dd6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a8cc0fd8c5371215c7c403aa9b1517dd6">resume_</a> ()</td></tr>
<tr class="memdesc:a8cc0fd8c5371215c7c403aa9b1517dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggered simulation resume callback. <br /></td></tr>
<tr class="separator:a8cc0fd8c5371215c7c403aa9b1517dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e3010cd3479ac90ef9e36d10cf8e5d"><td class="memItemLeft" align="right" valign="top"><a id="a77e3010cd3479ac90ef9e36d10cf8e5d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a77e3010cd3479ac90ef9e36d10cf8e5d">terminate_</a> ()</td></tr>
<tr class="memdesc:a77e3010cd3479ac90ef9e36d10cf8e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggered simulation terminate callback. <br /></td></tr>
<tr class="separator:a77e3010cd3479ac90ef9e36d10cf8e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee7777a04ea56b9e89a826001e48a74"><td class="memItemLeft" align="right" valign="top"><a id="a2ee7777a04ea56b9e89a826001e48a74"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a2ee7777a04ea56b9e89a826001e48a74">customEvent_</a> (const std::string &amp;event_name)</td></tr>
<tr class="memdesc:a2ee7777a04ea56b9e89a826001e48a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggered simulation custom named event. <br /></td></tr>
<tr class="separator:a2ee7777a04ea56b9e89a826001e48a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610c99015e30752fe1f4e122b9594611"><td class="memItemLeft" align="right" valign="top"><a id="a610c99015e30752fe1f4e122b9594611"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a610c99015e30752fe1f4e122b9594611">setupControllerTriggers_</a> ()</td></tr>
<tr class="memdesc:a610c99015e30752fe1f4e122b9594611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of custom simulation event triggers. <br /></td></tr>
<tr class="separator:a610c99015e30752fe1f4e122b9594611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14892e093187cb2702c5cb53515a12bd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a14892e093187cb2702c5cb53515a12bd">dumpNonDefaultParameters_</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *root, std::ostream &amp;out)</td></tr>
<tr class="memdesc:a14892e093187cb2702c5cb53515a12bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print and count the number of Parameters which have had their values changed to something different than the default.  <a href="classsparta_1_1app_1_1Simulation.html#a14892e093187cb2702c5cb53515a12bd">More...</a><br /></td></tr>
<tr class="separator:a14892e093187cb2702c5cb53515a12bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24b55f03d8bfda4fa05d9f380d79125"><td class="memItemLeft" align="right" valign="top"><a id="ac24b55f03d8bfda4fa05d9f380d79125"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#ac24b55f03d8bfda4fa05d9f380d79125">countNonDefaultParameters_</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *root)</td></tr>
<tr class="memdesc:ac24b55f03d8bfda4fa05d9f380d79125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same counting behavior as dumpNonDefaultParameters_ but does not print. <br /></td></tr>
<tr class="separator:ac24b55f03d8bfda4fa05d9f380d79125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc20642aafe1eae610f620f40655c9a1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#abc20642aafe1eae610f620f40655c9a1">reapplyVolatileParameters_</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *root)</td></tr>
<tr class="memdesc:abc20642aafe1eae610f620f40655c9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-read volatile parameter values from the virtual tree and write them to the parmeters. This is used by simulators if special parmeter application ordering is required.  <a href="classsparta_1_1app_1_1Simulation.html#abc20642aafe1eae610f620f40655c9a1">More...</a><br /></td></tr>
<tr class="separator:abc20642aafe1eae610f620f40655c9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a2810562889b8eb9861d746dd7e982"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#ae5a2810562889b8eb9861d746dd7e982">reapplyAllParameters_</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *root)</td></tr>
<tr class="memdesc:ae5a2810562889b8eb9861d746dd7e982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-read all parameter values from the virtual tree.  <a href="classsparta_1_1app_1_1Simulation.html#ae5a2810562889b8eb9861d746dd7e982">More...</a><br /></td></tr>
<tr class="separator:ae5a2810562889b8eb9861d746dd7e982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c0e80dff0aee45b5b749ea7b369990"><td class="memItemLeft" align="right" valign="top"><a id="a94c0e80dff0aee45b5b749ea7b369990"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a94c0e80dff0aee45b5b749ea7b369990">addTreeNodeExtensionFactory_</a> (const std::string &amp;extension_name, std::function&lt; <a class="el" href="classsparta_1_1TreeNode_1_1ExtensionsBase.html">TreeNode::ExtensionsBase</a> *()&gt; creator)</td></tr>
<tr class="memdesc:a94c0e80dff0aee45b5b749ea7b369990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include an extension factory for this simulation's device tree nodes. They will be given to specific tree nodes right after they are instantiated. Which extension(s) go to which tree node(s) is determined by configuration files. <br /></td></tr>
<tr class="separator:a94c0e80dff0aee45b5b749ea7b369990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e71a640813c8ba695a7d892cc4190b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#aa4e71a640813c8ba695a7d892cc4190b">runControlLoop_</a> (uint64_t run_time)</td></tr>
<tr class="memdesc:aa4e71a640813c8ba695a7d892cc4190b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter run-control loop causing the simulator to run or give control to an interactive shell.  <a href="classsparta_1_1app_1_1Simulation.html#aa4e71a640813c8ba695a7d892cc4190b">More...</a><br /></td></tr>
<tr class="separator:aa4e71a640813c8ba695a7d892cc4190b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c0bd7f205967b1732df4a2f7fcee24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#aa3c0bd7f205967b1732df4a2f7fcee24">runRaw_</a> (uint64_t run_time)</td></tr>
<tr class="memdesc:aa3c0bd7f205967b1732df4a2f7fcee24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run for specified "time".  <a href="classsparta_1_1app_1_1Simulation.html#aa3c0bd7f205967b1732df4a2f7fcee24">More...</a><br /></td></tr>
<tr class="separator:aa3c0bd7f205967b1732df4a2f7fcee24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ac03fbfb3067c435302fe6fc292bbd"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classsparta_1_1CounterBase.html">CounterBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a66ac03fbfb3067c435302fe6fc292bbd">findSemanticCounter_</a> (<a class="el" href="classsparta_1_1app_1_1Simulation.html#a2c1cbf112314f9a69927744a7855e18c">CounterSemantic</a> sem) const</td></tr>
<tr class="memdesc:a66ac03fbfb3067c435302fe6fc292bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements findSemanticCounter.  <a href="classsparta_1_1app_1_1Simulation.html#a66ac03fbfb3067c435302fe6fc292bbd">More...</a><br /></td></tr>
<tr class="separator:a66ac03fbfb3067c435302fe6fc292bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125e9ab50130264de923e8cf5be90299"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a125e9ab50130264de923e8cf5be90299">dumpDebugContent_</a> (std::string &amp;filename, const std::string &amp;exception, const std::string &amp;backtrace) noexcept</td></tr>
<tr class="memdesc:a125e9ab50130264de923e8cf5be90299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump debug content to a timestamped file regardless of debug-dumping control flags.  <a href="classsparta_1_1app_1_1Simulation.html#a125e9ab50130264de923e8cf5be90299">More...</a><br /></td></tr>
<tr class="separator:a125e9ab50130264de923e8cf5be90299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba75c652003673800b8e9b003bbabdd5"><td class="memItemLeft" align="right" valign="top"><a id="aba75c652003673800b8e9b003bbabdd5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#aba75c652003673800b8e9b003bbabdd5">delayedPeventStart_</a> ()</td></tr>
<tr class="memdesc:aba75c652003673800b8e9b003bbabdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">a Callback that officially starts pevent collection. <br /></td></tr>
<tr class="separator:aba75c652003673800b8e9b003bbabdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca61aebaa48be0325bd6da40629284e"><td class="memItemLeft" align="right" valign="top"><a id="aaca61aebaa48be0325bd6da40629284e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#aaca61aebaa48be0325bd6da40629284e">rootDescendantAdded_</a> (const <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> &amp;node_added)</td></tr>
<tr class="memdesc:aaca61aebaa48be0325bd6da40629284e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification callback invoked when a new node is attached as a descendant of this simulator's root node. <br /></td></tr>
<tr class="separator:aaca61aebaa48be0325bd6da40629284e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b7f474ef6397ca27f97974ae1f99d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#ab8b7f474ef6397ca27f97974ae1f99d4">attachTapTo_</a> (const <a class="el" href="classsparta_1_1log_1_1TapDescriptor.html">log::TapDescriptor</a> &amp;td, <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> *n)</td></tr>
<tr class="memdesc:ab8b7f474ef6397ca27f97974ae1f99d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and attaches a tap to a node based on its descriptor.  <a href="classsparta_1_1app_1_1Simulation.html#ab8b7f474ef6397ca27f97974ae1f99d4">More...</a><br /></td></tr>
<tr class="separator:ab8b7f474ef6397ca27f97974ae1f99d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67dbebf5b65a51f7c5d571324032e395"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a67dbebf5b65a51f7c5d571324032e395">attachReportTo_</a> (sparta::ReportRepository::DirectoryHandle directoryH, const <a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html">ReportDescriptor</a> &amp;rd, <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> *n, const std::vector&lt; std::string &gt; &amp;replacements)</td></tr>
<tr class="memdesc:a67dbebf5b65a51f7c5d571324032e395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and attaches a report to a node based on its descriptor.  <a href="classsparta_1_1app_1_1Simulation.html#a67dbebf5b65a51f7c5d571324032e395">More...</a><br /></td></tr>
<tr class="separator:a67dbebf5b65a51f7c5d571324032e395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27a270a2b4d4a64c38c8cbe0d101fb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#ae27a270a2b4d4a64c38c8cbe0d101fb0">checkAllVirtualParamsRead_</a> (const <a class="el" href="classsparta_1_1ParameterTree.html">ParameterTree</a> &amp;pt)</td></tr>
<tr class="memdesc:ae27a270a2b4d4a64c38c8cbe0d101fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that all virtual parameters have been read from a given tree.  <a href="classsparta_1_1app_1_1Simulation.html#ae27a270a2b4d4a64c38c8cbe0d101fb0">More...</a><br /></td></tr>
<tr class="separator:ae27a270a2b4d4a64c38c8cbe0d101fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af504e8785ef126d7a828041a5e3a3901"><td class="memItemLeft" align="right" valign="top"><a id="af504e8785ef126d7a828041a5e3a3901"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#af504e8785ef126d7a828041a5e3a3901">validateDescriptorCanBeAdded_</a> (const <a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html">ReportDescriptor</a> &amp;rd, const bool using_pyshell) const</td></tr>
<tr class="memdesc:af504e8785ef126d7a828041a5e3a3901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the given report descriptor can be added to this simulation. <br /></td></tr>
<tr class="separator:af504e8785ef126d7a828041a5e3a3901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed41a64afbf84897c0f0a868322a63d9"><td class="memItemLeft" align="right" valign="top"><a id="aed41a64afbf84897c0f0a868322a63d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#aed41a64afbf84897c0f0a868322a63d9">setupReports_</a> ()</td></tr>
<tr class="memdesc:aed41a64afbf84897c0f0a868322a63d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up all reports in this simulation. This can be called during finalization or deferred until later. <br /></td></tr>
<tr class="separator:aed41a64afbf84897c0f0a868322a63d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4edcf2f9e03b37d45537cd77149467"><td class="memItemLeft" align="right" valign="top"><a id="a4e4edcf2f9e03b37d45537cd77149467"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a4e4edcf2f9e03b37d45537cd77149467">setupDatabaseTriggers_</a> ()</td></tr>
<tr class="memdesc:a4e4edcf2f9e03b37d45537cd77149467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right before the main sim loop, this method is called in order to create any SimDB triggers the simulation was configured to use. These triggers dictate when database namespace(s) are opened and closed for reads and writes via the simdb::TableProxy class. <br /></td></tr>
<tr class="separator:a4e4edcf2f9e03b37d45537cd77149467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c69483010e5325c1fc50a9942e7ccc4"><td class="memItemLeft" align="right" valign="top"><a id="a4c69483010e5325c1fc50a9942e7ccc4"></a>
ReportDescVec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a4c69483010e5325c1fc50a9942e7ccc4">expandReportDescriptor_</a> (const <a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html">ReportDescriptor</a> &amp;rd) const</td></tr>
<tr class="memdesc:a4c69483010e5325c1fc50a9942e7ccc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the case where a comma-separated list of file formats was used to specify the output file format (i.e. 'csv, csv_cumulative'), this method will expand the report descriptors given to this simulation appropriately. <br /></td></tr>
<tr class="separator:a4c69483010e5325c1fc50a9942e7ccc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99ebbd80c2f79d7f294491dcc9f0aa4"><td class="memItemLeft" align="right" valign="top"><a id="af99ebbd80c2f79d7f294491dcc9f0aa4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#af99ebbd80c2f79d7f294491dcc9f0aa4">setupProfilers_</a> ()</td></tr>
<tr class="memdesc:af99ebbd80c2f79d7f294491dcc9f0aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up any heap profiler(s) used in this simulation. <br /></td></tr>
<tr class="separator:af99ebbd80c2f79d7f294491dcc9f0aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f2cdb557bcd3d08a4d9c3193171ec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a16f2cdb557bcd3d08a4d9c3193171ec1">setupStreamControllers_</a> ()</td></tr>
<tr class="memdesc:a16f2cdb557bcd3d08a4d9c3193171ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If report statistics are being streamed out of this simulation, share the run controllers's stream controller object with each of the statistics stream root nodes. To illustrate:  <a href="classsparta_1_1app_1_1Simulation.html#a16f2cdb557bcd3d08a4d9c3193171ec1">More...</a><br /></td></tr>
<tr class="separator:a16f2cdb557bcd3d08a4d9c3193171ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Virtual Setup Interface</div></td></tr>
<tr class="memitem:aecc889666b5da1b6891a6f1ed337fbc8"><td class="memItemLeft" align="right" valign="top"><a id="aecc889666b5da1b6891a6f1ed337fbc8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#aecc889666b5da1b6891a6f1ed337fbc8">buildTree_</a> ()=0</td></tr>
<tr class="memdesc:aecc889666b5da1b6891a6f1ed337fbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows implementer to create new nodes in the tree. <br /></td></tr>
<tr class="separator:aecc889666b5da1b6891a6f1ed337fbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d83dfcb8bf3490bff0e26b08f84c4bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a9d83dfcb8bf3490bff0e26b08f84c4bf">configureTree_</a> ()=0</td></tr>
<tr class="memdesc:a9d83dfcb8bf3490bff0e26b08f84c4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows implementer to manually configure the tree if required.  <a href="classsparta_1_1app_1_1Simulation.html#a9d83dfcb8bf3490bff0e26b08f84c4bf">More...</a><br /></td></tr>
<tr class="separator:a9d83dfcb8bf3490bff0e26b08f84c4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2481dd90dd3544ce4c5b385617c74cb6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a2481dd90dd3544ce4c5b385617c74cb6">bindTree_</a> ()=0</td></tr>
<tr class="memdesc:a2481dd90dd3544ce4c5b385617c74cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows implementer to bind ports to gether.  <a href="classsparta_1_1app_1_1Simulation.html#a2481dd90dd3544ce4c5b385617c74cb6">More...</a><br /></td></tr>
<tr class="separator:a2481dd90dd3544ce4c5b385617c74cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3df55c9ec9fc8419f77eceaf522549e1"><td class="memItemLeft" align="right" valign="top"><a id="a3df55c9ec9fc8419f77eceaf522549e1"></a>
std::shared_ptr&lt; <a class="el" href="classsparta_1_1app_1_1Simulation_1_1SimulationController.html">SimulationController</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a3df55c9ec9fc8419f77eceaf522549e1">controller_</a></td></tr>
<tr class="memdesc:a3df55c9ec9fc8419f77eceaf522549e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom controller to handle various simulation events. <br /></td></tr>
<tr class="separator:a3df55c9ec9fc8419f77eceaf522549e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920342666783666f2671968b660b8018"><td class="memItemLeft" align="right" valign="top"><a id="a920342666783666f2671968b660b8018"></a>
std::vector&lt; std::shared_ptr&lt; trigger::ExpressionTrigger &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a920342666783666f2671968b660b8018">controller_triggers_</a></td></tr>
<tr class="memdesc:a920342666783666f2671968b660b8018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression triggers to invoke custom simulation events via the <a class="el" href="classsparta_1_1app_1_1Simulation_1_1SimulationController.html" title="This class is used for simulation control callbacks. The callback conditions (trigger expressions) ar...">SimulationController</a> object. <br /></td></tr>
<tr class="separator:a920342666783666f2671968b660b8018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65734878510428fcaada8494008249e9"><td class="memItemLeft" align="right" valign="top"><a id="a65734878510428fcaada8494008249e9"></a>
std::shared_ptr&lt; <a class="el" href="classsparta_1_1MemoryProfiler.html">sparta::MemoryProfiler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a65734878510428fcaada8494008249e9">memory_profiler_</a></td></tr>
<tr class="memdesc:a65734878510428fcaada8494008249e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap profiler(s), if any. <br /></td></tr>
<tr class="separator:a65734878510428fcaada8494008249e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ff2f7203dffc38996e5eec25abaf79"><td class="memItemLeft" align="right" valign="top"><a id="a30ff2f7203dffc38996e5eec25abaf79"></a>
std::unique_ptr&lt; sparta::ReportRepository &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a30ff2f7203dffc38996e5eec25abaf79">report_repository_</a></td></tr>
<tr class="memdesc:a30ff2f7203dffc38996e5eec25abaf79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repository of all reports for this simulation. <br /></td></tr>
<tr class="separator:a30ff2f7203dffc38996e5eec25abaf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b48925db5f3c65de0f7536ddc9057c"><td class="memItemLeft" align="right" valign="top"><a id="a10b48925db5f3c65de0f7536ddc9057c"></a>
<a class="el" href="classsparta_1_1app_1_1Backtrace.html">Backtrace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a10b48925db5f3c65de0f7536ddc9057c">backtrace_</a></td></tr>
<tr class="memdesc:a10b48925db5f3c65de0f7536ddc9057c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backtracing utility for error signals. <br /></td></tr>
<tr class="separator:a10b48925db5f3c65de0f7536ddc9057c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d11210dbf47d4d284e2fd8a93fb9188"><td class="memItemLeft" align="right" valign="top"><a id="a8d11210dbf47d4d284e2fd8a93fb9188"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a8d11210dbf47d4d284e2fd8a93fb9188">sim_name_</a></td></tr>
<tr class="memdesc:a8d11210dbf47d4d284e2fd8a93fb9188"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">Simulation</a> name. <br /></td></tr>
<tr class="separator:a8d11210dbf47d4d284e2fd8a93fb9188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea47a7fa129937a280dbf2a8103de8e"><td class="memItemLeft" align="right" valign="top"><a id="a1ea47a7fa129937a280dbf2a8103de8e"></a>
std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsparta_1_1log_1_1Tap.html">sparta::log::Tap</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a1ea47a7fa129937a280dbf2a8103de8e">taps_to_del_</a></td></tr>
<tr class="memdesc:a1ea47a7fa129937a280dbf2a8103de8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-specified Taps to delete at teardown. These should outlast the entire tree so that they can intercept destruction log messages. <br /></td></tr>
<tr class="separator:a1ea47a7fa129937a280dbf2a8103de8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a881032c6d850859501e4eb9e301d2"><td class="memItemLeft" align="right" valign="top"><a id="ac4a881032c6d850859501e4eb9e301d2"></a>
<a class="el" href="classsparta_1_1ResourceSet.html">sparta::ResourceSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#ac4a881032c6d850859501e4eb9e301d2">res_list_</a></td></tr>
<tr class="memdesc:ac4a881032c6d850859501e4eb9e301d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of of resources available to this simulation. This must outlast destruction of the tree root_ and its children. <br /></td></tr>
<tr class="separator:ac4a881032c6d850859501e4eb9e301d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c334ab19e2ebe55fdae2fb5f5804bd"><td class="memItemLeft" align="right" valign="top"><a id="a93c334ab19e2ebe55fdae2fb5f5804bd"></a>
<a class="el" href="classsparta_1_1Scheduler.html">Scheduler</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a93c334ab19e2ebe55fdae2fb5f5804bd">scheduler_</a></td></tr>
<tr class="memdesc:a93c334ab19e2ebe55fdae2fb5f5804bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">Scheduler</a> this simulation will use. If no scheduler was given to the simulation's constructor, it will use the singleton scheduler. <br /></td></tr>
<tr class="separator:a93c334ab19e2ebe55fdae2fb5f5804bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa491b51e05e04f16bb3960c846014f2"><td class="memItemLeft" align="right" valign="top"><a id="afa491b51e05e04f16bb3960c846014f2"></a>
<a class="el" href="classsparta_1_1ClockManager.html">sparta::ClockManager</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#afa491b51e05e04f16bb3960c846014f2">clk_manager_</a></td></tr>
<tr class="memdesc:afa491b51e05e04f16bb3960c846014f2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">Clock</a> manager for all clocks in simulation. <br /></td></tr>
<tr class="separator:afa491b51e05e04f16bb3960c846014f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f23d012e258cd7d937e75dad9905d15"><td class="memItemLeft" align="right" valign="top"><a id="a2f23d012e258cd7d937e75dad9905d15"></a>
std::unique_ptr&lt; Report &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a2f23d012e258cd7d937e75dad9905d15">auto_summary_report_</a></td></tr>
<tr class="memdesc:a2f23d012e258cd7d937e75dad9905d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default automaticly generated report containing the entire simulation. <br /></td></tr>
<tr class="separator:a2f23d012e258cd7d937e75dad9905d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2152bfc76dc0bcf64adf070a75e7671e"><td class="memItemLeft" align="right" valign="top"><a id="a2152bfc76dc0bcf64adf070a75e7671e"></a>
std::unique_ptr&lt; <a class="el" href="classsparta_1_1RootTreeNode.html">sparta::RootTreeNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a2152bfc76dc0bcf64adf070a75e7671e">clk_root_node_</a></td></tr>
<tr class="memdesc:a2152bfc76dc0bcf64adf070a75e7671e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root node containing the clock tree (called "clocks") <br /></td></tr>
<tr class="separator:a2152bfc76dc0bcf64adf070a75e7671e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade66465945aa5d4589d9b8dd957707a4"><td class="memItemLeft" align="right" valign="top"><a id="ade66465945aa5d4589d9b8dd957707a4"></a>
Clock::Handle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#ade66465945aa5d4589d9b8dd957707a4">root_clk_</a></td></tr>
<tr class="memdesc:ade66465945aa5d4589d9b8dd957707a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root of clock tree (direct child of clk_root_node_). Represents hypercycles. Destruct after all nodes. <br /></td></tr>
<tr class="separator:ade66465945aa5d4589d9b8dd957707a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5945b6e45da6cef6d989a77de55a53c1"><td class="memItemLeft" align="right" valign="top"><a id="a5945b6e45da6cef6d989a77de55a53c1"></a>
<a class="el" href="classsparta_1_1RootTreeNode.html">sparta::RootTreeNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a5945b6e45da6cef6d989a77de55a53c1">root_</a></td></tr>
<tr class="memdesc:a5945b6e45da6cef6d989a77de55a53c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root of device tree: "top". Destruct after all non-root nodes (see to_delete_) <br /></td></tr>
<tr class="separator:a5945b6e45da6cef6d989a77de55a53c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb97c8691a2c5f6faec19a4022e9a24b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsparta_1_1app_1_1MetaTreeNode.html">MetaTreeNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#aeb97c8691a2c5f6faec19a4022e9a24b">meta_</a></td></tr>
<tr class="memdesc:aeb97c8691a2c5f6faec19a4022e9a24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-tree containing simulation meta-information in parameters in "meta.params.fizbin". Destruct after all non-root nodes (see to_delete_)  <a href="classsparta_1_1app_1_1Simulation.html#aeb97c8691a2c5f6faec19a4022e9a24b">More...</a><br /></td></tr>
<tr class="separator:aeb97c8691a2c5f6faec19a4022e9a24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009c9f68e170b337b51076e018eb6b09"><td class="memItemLeft" align="right" valign="top"><a id="a009c9f68e170b337b51076e018eb6b09"></a>
std::unordered_map&lt; std::string, std::function&lt; <a class="el" href="classsparta_1_1TreeNode_1_1ExtensionsBase.html">TreeNode::ExtensionsBase</a> *()&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a009c9f68e170b337b51076e018eb6b09">tree_node_extension_factories_</a></td></tr>
<tr class="memdesc:a009c9f68e170b337b51076e018eb6b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tree node extension factories by name. <br /></td></tr>
<tr class="separator:a009c9f68e170b337b51076e018eb6b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b90e4aa5cee97800ec005aab4e2eb51"><td class="memItemLeft" align="right" valign="top"><a id="a4b90e4aa5cee97800ec005aab4e2eb51"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a4b90e4aa5cee97800ec005aab4e2eb51">framework_finalized_</a> = false</td></tr>
<tr class="memdesc:a4b90e4aa5cee97800ec005aab4e2eb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the framework been finalized. <br /></td></tr>
<tr class="separator:a4b90e4aa5cee97800ec005aab4e2eb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6564b798cb5cc08de08bd4ea6dbb0b"><td class="memItemLeft" align="right" valign="top"><a id="a0c6564b798cb5cc08de08bd4ea6dbb0b"></a>
std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a0c6564b798cb5cc08de08bd4ea6dbb0b">to_delete_</a></td></tr>
<tr class="memdesc:a0c6564b798cb5cc08de08bd4ea6dbb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of TreeNodes to delete automatically at destruction. Add any nodes allocated to this list to automatically manage them. <br /></td></tr>
<tr class="separator:a0c6564b798cb5cc08de08bd4ea6dbb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514157a4eecd56c000397737b8c883a7"><td class="memItemLeft" align="right" valign="top"><a id="a514157a4eecd56c000397737b8c883a7"></a>
<a class="el" href="classsparta_1_1app_1_1SimulationConfiguration.html">SimulationConfiguration</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>sim_config_</b> {nullptr}</td></tr>
<tr class="separator:a514157a4eecd56c000397737b8c883a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb38795e3883bd87e514d81dd59f4cd6"><td class="memItemLeft" align="right" valign="top"><a id="abb38795e3883bd87e514d81dd59f4cd6"></a>
const <a class="el" href="classsparta_1_1app_1_1FeatureConfiguration.html">FeatureConfiguration</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>feature_config_</b> {nullptr}</td></tr>
<tr class="separator:abb38795e3883bd87e514d81dd59f4cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa51da1aa48e4920aca5c7b45d96e2b"><td class="memItemLeft" align="right" valign="top"><a id="a2aa51da1aa48e4920aca5c7b45d96e2b"></a>
<a class="el" href="classsparta_1_1log_1_1Tap.html">sparta::log::Tap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a2aa51da1aa48e4920aca5c7b45d96e2b">warn_to_cerr_</a></td></tr>
<tr class="memdesc:a2aa51da1aa48e4920aca5c7b45d96e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tap which warns to cerr. <br /></td></tr>
<tr class="separator:a2aa51da1aa48e4920aca5c7b45d96e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bd49cf2de03d406ee36f40de86f660"><td class="memItemLeft" align="right" valign="top"><a id="a65bd49cf2de03d406ee36f40de86f660"></a>
std::unique_ptr&lt; <a class="el" href="classsparta_1_1log_1_1Tap.html">sparta::log::Tap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a65bd49cf2de03d406ee36f40de86f660">warn_to_file_</a></td></tr>
<tr class="memdesc:a65bd49cf2de03d406ee36f40de86f660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tap which, if constructed, will write all warnings to a file. <br /></td></tr>
<tr class="separator:a65bd49cf2de03d406ee36f40de86f660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c128c63796931bd74893fef77a95a85"><td class="memItemLeft" align="right" valign="top"><a id="a1c128c63796931bd74893fef77a95a85"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a1c128c63796931bd74893fef77a95a85">num_fired_</a></td></tr>
<tr class="memdesc:a1c128c63796931bd74893fef77a95a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of scheduler events firerd. <br /></td></tr>
<tr class="separator:a1c128c63796931bd74893fef77a95a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9e76e2baeb0f04832ca906728a8a37"><td class="memItemLeft" align="right" valign="top"><a id="abd9e76e2baeb0f04832ca906728a8a37"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#abd9e76e2baeb0f04832ca906728a8a37">print_dag_</a> = false</td></tr>
<tr class="memdesc:abd9e76e2baeb0f04832ca906728a8a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should the <a class="el" href="classsparta_1_1DAG.html">DAG</a> be printed after it is built. <br /></td></tr>
<tr class="separator:abd9e76e2baeb0f04832ca906728a8a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffb198472b3d3d3a614cdd65d714e78"><td class="memItemLeft" align="right" valign="top"><a id="adffb198472b3d3d3a614cdd65d714e78"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#adffb198472b3d3d3a614cdd65d714e78">validate_post_run_</a> = false</td></tr>
<tr class="memdesc:adffb198472b3d3d3a614cdd65d714e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate after running. <br /></td></tr>
<tr class="separator:adffb198472b3d3d3a614cdd65d714e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd0db7f50ed38ebec5e2136046bf566"><td class="memItemLeft" align="right" valign="top"><a id="aebd0db7f50ed38ebec5e2136046bf566"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#aebd0db7f50ed38ebec5e2136046bf566">pipeline_collection_prefix_</a></td></tr>
<tr class="memdesc:aebd0db7f50ed38ebec5e2136046bf566"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1Pipeline.html" title="A simple pipeline.">Pipeline</a> collection prefix. <br /></td></tr>
<tr class="separator:aebd0db7f50ed38ebec5e2136046bf566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f97f4cf4bd2620d6d332fcf1983662e"><td class="memItemLeft" align="right" valign="top"><a id="a6f97f4cf4bd2620d6d332fcf1983662e"></a>
<a class="el" href="classsparta_1_1app_1_1ReportDescriptorCollection.html">ReportDescriptorCollection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a6f97f4cf4bd2620d6d332fcf1983662e">rep_descs_</a></td></tr>
<tr class="memdesc:a6f97f4cf4bd2620d6d332fcf1983662e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of Report descriptors applicable to the simulation. These descriptors are used as the tree is built to find nodes on which to instantiate them. These are still used following building of the device tree in order to determine where the completed reports should be saved. This must be destroyed or no longer accessed once the reports_ vector is destroyed. <br /></td></tr>
<tr class="separator:a6f97f4cf4bd2620d6d332fcf1983662e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e1e832498fb4027a3c19f761330d4b"><td class="memItemLeft" align="right" valign="top"><a id="ab0e1e832498fb4027a3c19f761330d4b"></a>
std::unique_ptr&lt; <a class="el" href="classsparta_1_1app_1_1ReportConfiguration.html">ReportConfiguration</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#ab0e1e832498fb4027a3c19f761330d4b">report_config_</a></td></tr>
<tr class="memdesc:ab0e1e832498fb4027a3c19f761330d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report configuration object which wraps the simulation's <a class="el" href="classsparta_1_1app_1_1ReportDescriptorCollection.html" title="This collection of ReportDescriptors is designed to never deallocate memory once it has been allocate...">ReportDescriptorCollection</a>. <br /></td></tr>
<tr class="separator:ab0e1e832498fb4027a3c19f761330d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6574712c33d72a3a93e6eefef3365f3"><td class="memItemLeft" align="right" valign="top"><a id="ac6574712c33d72a3a93e6eefef3365f3"></a>
ExtensionDescriptorVec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#ac6574712c33d72a3a93e6eefef3365f3">extension_descs_</a></td></tr>
<tr class="memdesc:ac6574712c33d72a3a93e6eefef3365f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep the extension descriptors alive for the entire simulation. The <a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">Simulation</a> base class is meant to actually allocate and own this memory (named parameter sets) even though simulation subclasses are the only ones who use these extended parameters sets. <br /></td></tr>
<tr class="separator:ac6574712c33d72a3a93e6eefef3365f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603761e3334b47b6cfc5e406f61ba72c"><td class="memItemLeft" align="right" valign="top"><a id="a603761e3334b47b6cfc5e406f61ba72c"></a>
std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nodes_given_extensions_</b></td></tr>
<tr class="separator:a603761e3334b47b6cfc5e406f61ba72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82f9aa9ab35c34c8adaa911e8813221"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsparta_1_1app_1_1ConfigApplicator.html">ConfigApplicator</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#af82f9aa9ab35c34c8adaa911e8813221">user_configs_</a></td></tr>
<tr class="memdesc:af82f9aa9ab35c34c8adaa911e8813221"><td class="mdescLeft">&#160;</td><td class="mdescRight">User configuration vector stored at "preprocessParameters".  <a href="classsparta_1_1app_1_1Simulation.html#af82f9aa9ab35c34c8adaa911e8813221">More...</a><br /></td></tr>
<tr class="separator:af82f9aa9ab35c34c8adaa911e8813221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03c6c056cdb5d27b847f7ab79441ab3"><td class="memItemLeft" align="right" valign="top"><a id="ac03c6c056cdb5d27b847f7ab79441ab3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#ac03c6c056cdb5d27b847f7ab79441ab3">using_final_config_</a> = false</td></tr>
<tr class="memdesc:ac03c6c056cdb5d27b847f7ab79441ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">tells the simulator that we are using the final config option and need to prevent parameter set callbacks and the simulator itself cannot change parameters. <br /></td></tr>
<tr class="separator:ac03c6c056cdb5d27b847f7ab79441ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973915a62ff9a2fe6f7489c4c7699753"><td class="memItemLeft" align="right" valign="top"><a id="a973915a62ff9a2fe6f7489c4c7699753"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a973915a62ff9a2fe6f7489c4c7699753">pevent_warmup_icount_</a> = 0</td></tr>
<tr class="memdesc:a973915a62ff9a2fe6f7489c4c7699753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warmup period in instructions before logging pevents. <br /></td></tr>
<tr class="separator:a973915a62ff9a2fe6f7489c4c7699753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeede1e5de1abf84f36671905bef868"><td class="memItemLeft" align="right" valign="top"><a id="afdeede1e5de1abf84f36671905bef868"></a>
SpartaHandler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#afdeede1e5de1abf84f36671905bef868">pevent_start_handler_</a></td></tr>
<tr class="memdesc:afdeede1e5de1abf84f36671905bef868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for pevent startup. <br /></td></tr>
<tr class="separator:afdeede1e5de1abf84f36671905bef868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7b387026f183f8b1ce8de52fc05af1"><td class="memItemLeft" align="right" valign="top"><a id="a8d7b387026f183f8b1ce8de52fc05af1"></a>
std::unique_ptr&lt; trigger::CounterTrigger &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a8d7b387026f183f8b1ce8de52fc05af1">pevent_start_trigger_</a></td></tr>
<tr class="memdesc:a8d7b387026f183f8b1ce8de52fc05af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instruction trigger for observing pevent warmup. <br /></td></tr>
<tr class="separator:a8d7b387026f183f8b1ce8de52fc05af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653f51ddbda9b03dd8d3cbd36680cfad"><td class="memItemLeft" align="right" valign="top"><a id="a653f51ddbda9b03dd8d3cbd36680cfad"></a>
std::unique_ptr&lt; <a class="el" href="classsparta_1_1app_1_1LoggingTrigger.html">LoggingTrigger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a653f51ddbda9b03dd8d3cbd36680cfad">log_trigger_</a></td></tr>
<tr class="memdesc:a653f51ddbda9b03dd8d3cbd36680cfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger for starting logging. <br /></td></tr>
<tr class="separator:a653f51ddbda9b03dd8d3cbd36680cfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513e5112d8d3a68d6c7e775231817167"><td class="memItemLeft" align="right" valign="top"><a id="a513e5112d8d3a68d6c7e775231817167"></a>
std::unique_ptr&lt; trigger::Trigger &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a513e5112d8d3a68d6c7e775231817167">debug_trigger_</a></td></tr>
<tr class="memdesc:a513e5112d8d3a68d6c7e775231817167"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trigger used to turn on debug useful options at a given cycle, right now this only turns on pipeline collection. <br /></td></tr>
<tr class="separator:a513e5112d8d3a68d6c7e775231817167"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Simulator which builds a sparta DeviceTree. </p>

<p class="definition">Definition at line <a class="el" href="Simulation_8hpp_source.html#l00064">64</a> of file <a class="el" href="Simulation_8hpp_source.html">Simulation.hpp</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a2c1cbf112314f9a69927744a7855e18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1cbf112314f9a69927744a7855e18c">&#9670;&nbsp;</a></span>CounterSemantic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classsparta_1_1app_1_1Simulation.html#a2c1cbf112314f9a69927744a7855e18c">sparta::app::Simulation::CounterSemantic</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of semantics attached to certain counters. It is the responsibility of subclasses to implement findSemanticCounter such taht it can satisfy requests for counters having these semantics. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2c1cbf112314f9a69927744a7855e18ca6802d1020aafd2ec136d237bffb8c56b"></a>CSEM_INSTRUCTIONS&#160;</td><td class="fielddoc"><p>Instruction count semantic (usually core0) </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Simulation_8hpp_source.html#l00074">74</a> of file <a class="el" href="Simulation_8hpp_source.html">Simulation.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7502b73eb6552794bb61eda46bdea821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7502b73eb6552794bb61eda46bdea821">&#9670;&nbsp;</a></span>Simulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sparta::app::Simulation::Simulation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sim_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Scheduler.html">Scheduler</a> *&#160;</td>
          <td class="paramname"><em>scheduler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deferred configuration constructor. Subsequent call to configure must be made before building/configuring/finalizing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sim_name</td><td>Name of the simulator </td></tr>
    <tr><td class="paramname">scheduler</td><td>Pointer to the <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">Scheduler</a> that this <a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">Simulation</a> operates with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a00fc8fabf896719884117a30f9062d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00fc8fabf896719884117a30f9062d06">&#9670;&nbsp;</a></span>addReport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::Simulation::addReport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html">ReportDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>rep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a report. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Must be done before root is finalized or finalizing </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rep</td><td>Descriptor of report to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e53f536fa3ab32e66dbb67242569f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e53f536fa3ab32e66dbb67242569f29">&#9670;&nbsp;</a></span>asyncStop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sparta::app::Simulation::asyncStop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously stop the run. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is not thread safe. This is just a call that can come from a signal handler or within the simulator model code to stop at the next tick boundary. </dd></dl>

</div>
</div>
<a id="a67dbebf5b65a51f7c5d571324032e395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67dbebf5b65a51f7c5d571324032e395">&#9670;&nbsp;</a></span>attachReportTo_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::Simulation::attachReportTo_ </td>
          <td>(</td>
          <td class="paramtype">sparta::ReportRepository::DirectoryHandle&#160;</td>
          <td class="paramname"><em>directoryH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1app_1_1ReportDescriptor.html">ReportDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>rd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and attaches a report to a node based on its descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directoryH</td><td>Repository directory where the new report goes </td></tr>
    <tr><td class="paramname">def_file</td><td>Report definition file (.yaml) </td></tr>
    <tr><td class="paramname">n</td><td>Node to which report should be attached </td></tr>
    <tr><td class="paramname">replacements</td><td>Set of replacements to give to the report definition parser as substitutions in the report name or report's local stat names </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The report will be created and appended to the repository </dd></dl>

</div>
</div>
<a id="ab8b7f474ef6397ca27f97974ae1f99d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b7f474ef6397ca27f97974ae1f99d4">&#9670;&nbsp;</a></span>attachTapTo_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::Simulation::attachTapTo_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1log_1_1TapDescriptor.html">log::TapDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>td</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and attaches a tap to a node based on its descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">td</td><td>Descriptor of tap to create and attach </td></tr>
    <tr><td class="paramname">n</td><td>Node to which tap should be attached </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tap will be created and appended to the taps_to_del_ list. </dd>
<dd>
td will have its usage count incremented </dd></dl>

</div>
</div>
<a id="a2481dd90dd3544ce4c5b385617c74cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2481dd90dd3544ce4c5b385617c74cb6">&#9670;&nbsp;</a></span>bindTree_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sparta::app::Simulation::bindTree_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows implementer to bind ports to gether. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Tree will be finalized </dd>
<dd>
Logging taps specified on the command line will be attached to appropriate nodes </dd></dl>

</div>
</div>
<a id="a319e9c4e7418f8f953e1a527b4feff8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319e9c4e7418f8f953e1a527b4feff8a">&#9670;&nbsp;</a></span>buildTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::Simulation::buildTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds hard-coded device tree. </p>
<dl class="section note"><dt>Note</dt><dd>Result can be dumped with <a class="el" href="classsparta_1_1app_1_1Simulation.html#addcee1dc30a0f93c2c55379cb69227f7" title="Returns the tree root.">getRoot()</a>-&gt;renderSubtree(-1, true); to show everything in the device tree.</dd></dl>
<p>Root will be in the <a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366abd4d809ed80d002633d62a28b233d397" title="Setting up tree hierarchy only (initial state)">TreeNode::TREE_BUILDING</a> phase </p>

</div>
</div>
<a id="ae27a270a2b4d4a64c38c8cbe0d101fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27a270a2b4d4a64c38c8cbe0d101fb0">&#9670;&nbsp;</a></span>checkAllVirtualParamsRead_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::Simulation::checkAllVirtualParamsRead_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1ParameterTree.html">ParameterTree</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that all virtual parameters have been read from a given tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pt</td><td><a class="el" href="classsparta_1_1ParameterTree.html" title="Virtual Parameter Tree. This represents a tree of parameters read from some source but does not neces...">ParameterTree</a> to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if any parameters are unread. Exception will explain which parameter is a problem and where it came from (e.g. which file) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a894a3af52b6ae904b529420c78f2873c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894a3af52b6ae904b529420c78f2873c">&#9670;&nbsp;</a></span>configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::Simulation::configure </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1app_1_1SimulationConfiguration.html">SimulationConfiguration</a> *&#160;</td>
          <td class="paramname"><em>configuration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_pyshell</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the simulator after construction. Necessary only when using the simple constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>command line argc (used by the python shell) </td></tr>
    <tr><td class="paramname">argv</td><td>command line argv (used by the python shell) </td></tr>
    <tr><td class="paramname">configuration</td><td>The <a class="el" href="classsparta_1_1app_1_1SimulationConfiguration.html" title="Configuration applicator class that is used for configuring a simulator. Works in conjunction with sp...">SimulationConfiguration</a> object to initialize this <a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">Simulation</a> object </td></tr>
    <tr><td class="paramname">use_pyshell</td><td>Enable the python shell (experimental) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54a0e00d7f5998fec76bb62061a475ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a0e00d7f5998fec76bb62061a475ed">&#9670;&nbsp;</a></span>configureTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::Simulation::configureTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the tree with some node-local config files, params, and node-specific parameters. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Tree must be in building phase. Check <a class="el" href="classsparta_1_1app_1_1Simulation.html#addcee1dc30a0f93c2c55379cb69227f7" title="Returns the tree root.">getRoot()</a>-&gt;isBuilding()</dd></dl>
<p>Root will be in the <a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366a4ad63ff1aeafd781623e5b9dd8e95dc1" title="Setting parameters, ports, and other pre-instantiation attributes. Hierarchy cannot be modified.">TreeNode::TREE_CONFIGURING</a> phase </p>

</div>
</div>
<a id="a9d83dfcb8bf3490bff0e26b08f84c4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d83dfcb8bf3490bff0e26b08f84c4bf">&#9670;&nbsp;</a></span>configureTree_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sparta::app::Simulation::configureTree_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows implementer to manually configure the tree if required. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Tree will be built </dd>
<dd>
Tree will have all command-line parameters applied </dd></dl>

</div>
</div>
<a id="a125e9ab50130264de923e8cf5be90299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125e9ab50130264de923e8cf5be90299">&#9670;&nbsp;</a></span>dumpDebugContent_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::app::Simulation::dumpDebugContent_ </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>exception</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>backtrace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump debug content to a timestamped file regardless of debug-dumping control flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Filename of output or "" if output was written to cerr. Updated by this method even if the are errors </td></tr>
    <tr><td class="paramname">exception</td><td>Exception to write at top of tile </td></tr>
    <tr><td class="paramname">backtrace</td><td>String describing backtrace at the time the exception was thrown </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there were no issues. False if output is possible truncated due to an internal exception </dd></dl>

</div>
</div>
<a id="a51f4d6092177b67c9bf1f83cf9ed39d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f4d6092177b67c9bf1f83cf9ed39d9">&#9670;&nbsp;</a></span>dumpDebugContentIfAllowed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::Simulation::dumpDebugContentIfAllowed </td>
          <td>(</td>
          <td class="paramtype">std::exception_ptr&#160;</td>
          <td class="paramname"><em>eptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forcec</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if debug content needs to be dumped and dump if so. Uses dumpDebugContent to dump. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eptr</td><td>Exception pointer to inspect </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>Force the dump regardless of configuration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5a5f772032be533a68e73d37b721472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a5f772032be533a68e73d37b721472">&#9670;&nbsp;</a></span>dumpMetaParameterTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::Simulation::dumpMetaParameterTable </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write meta-data tree parameters to given ostream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>osteam to which meta parameter values will be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14892e093187cb2702c5cb53515a12bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14892e093187cb2702c5cb53515a12bd">&#9670;&nbsp;</a></span>dumpNonDefaultParameters_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::app::Simulation::dumpNonDefaultParameters_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print and count the number of Parameters which have had their values changed to something different than the default. </p>
<dl class="section note"><dt>Note</dt><dd>"default" refers to the parameter default OR the architecture (&ndash;arch) "default" override. </dd>
<dd>
uses <a class="el" href="classsparta_1_1ParameterBase.html#ae297438f7452736fc86dc6df8a477925" title="Is this parameter&#39;s current value the default value.">sparta::ParameterBase::isDefault</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of non-default parameters </dd></dl>

</div>
</div>
<a id="a18ede64ec543df1bb56a71618fe82757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ede64ec543df1bb56a71618fe82757">&#9670;&nbsp;</a></span>finalizeFramework()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::Simulation::finalizeFramework </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize framework before running. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Tree will be in the <a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366ad3c0a8e691ca35c690e5055d2c888789" title="Tree and all resources have been instantiated. No more configuration/connection allowed.">TreeNode::TREE_FINALIZED</a> phase. Check <a class="el" href="classsparta_1_1app_1_1Simulation.html#addcee1dc30a0f93c2c55379cb69227f7" title="Returns the tree root.">getRoot()</a>-&gt;isFinalized() </dd></dl>

</div>
</div>
<a id="a200bdd31a21e24a242770fcb8e7fff5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200bdd31a21e24a242770fcb8e7fff5f">&#9670;&nbsp;</a></span>finalizeTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::Simulation::finalizeTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes the device tree. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Tree must be in configuring phase. Check <a class="el" href="classsparta_1_1app_1_1Simulation.html#addcee1dc30a0f93c2c55379cb69227f7" title="Returns the tree root.">getRoot()</a>-&gt;isConfiguring() </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Tree will be finalized. Check <a class="el" href="classsparta_1_1app_1_1Simulation.html#addcee1dc30a0f93c2c55379cb69227f7" title="Returns the tree root.">getRoot()</a>-&gt;isFinalized() </dd>
<dd>
Root will be in the <a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366ad3c0a8e691ca35c690e5055d2c888789" title="Tree and all resources have been instantiated. No more configuration/connection allowed.">TreeNode::TREE_FINALIZED</a> phase </dd></dl>

</div>
</div>
<a id="acbdbeb54718f1a0376d3f51593a23adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbdbeb54718f1a0376d3f51593a23adc">&#9670;&nbsp;</a></span>findSemanticCounter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsparta_1_1CounterBase.html">CounterBase</a>* sparta::app::Simulation::findSemanticCounter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a2c1cbf112314f9a69927744a7855e18c">CounterSemantic</a>&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a counter by its semantic (if such a counter exists). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>Semantic of counter to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>uses virtual findSemanticCounter_ </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">Simulation</a> must be finalized and not in teardown </dd></dl>

<p class="definition">Definition at line <a class="el" href="Simulation_8hpp_source.html#l00362">362</a> of file <a class="el" href="Simulation_8hpp_source.html">Simulation.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1app_1_1Simulation_acbdbeb54718f1a0376d3f51593a23adc_cgraph.png" border="0" usemap="#aclasssparta_1_1app_1_1Simulation_acbdbeb54718f1a0376d3f51593a23adc_cgraph" alt=""/></div>
<map name="classsparta_1_1app_1_1Simulation_acbdbeb54718f1a0376d3f51593a23adc_cgraph" id="aclasssparta_1_1app_1_1Simulation_acbdbeb54718f1a0376d3f51593a23adc_cgraph">
<area shape="rect" title="Get a counter by its semantic (if such a counter exists)." alt="" coords="5,71,157,112"/>
<area shape="rect" href="classsparta_1_1app_1_1Simulation.html#a66ac03fbfb3067c435302fe6fc292bbd" title="Implements findSemanticCounter." alt="" coords="205,5,360,47"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html#ac8edefaf47c41a0be179827e657955d5" title="Is this node (and thus the entire tree above it) &quot;finalized&quot;." alt="" coords="209,71,356,112"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html#a8555fc19699141ca78722846bd2e2dc3" title="Is this node (and thus the entire tree above it) in the &quot;teardown&quot; phase." alt="" coords="209,136,356,177"/>
</map>
</div>

</div>
</div>
<a id="a66ac03fbfb3067c435302fe6fc292bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ac03fbfb3067c435302fe6fc292bbd">&#9670;&nbsp;</a></span>findSemanticCounter_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classsparta_1_1CounterBase.html">CounterBase</a>* sparta::app::Simulation::findSemanticCounter_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1app_1_1Simulation.html#a2c1cbf112314f9a69927744a7855e18c">CounterSemantic</a>&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements findSemanticCounter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>Semantic of counter to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">Simulation</a> must be finalized and not in teardown </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to counter with this semantic of nullptr if none. This method must return the same pointer each call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Simulation_8hpp_source.html#l00625">625</a> of file <a class="el" href="Simulation_8hpp_source.html">Simulation.hpp</a>.</p>

</div>
</div>
<a id="a3e7055b63e8e5ae50695a3556ee09560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7055b63e8e5ae50695a3556ee09560">&#9670;&nbsp;</a></span>getDatabaseRoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">simdb::DatabaseRoot* sparta::app::Simulation::getDatabaseRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the database root for this simulation. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the DatabaseRoot</dd></dl>
<p>This is a container that holds all databases the simulation is using. The underlying ObjectManager methods such as getTable() and findObject() can be accessed indirectly using the ObjectDatabase class (nested class inside ObjectManager). For example, say that we ran a simulation using the &ndash;report command line option, and we want to go through the DatabaseRoot to get the <a class="el" href="classsparta_1_1StatisticInstance.html" title="Instance of either a StatisticDef or CounterBase or an Expression. Has a sample window (simulator tic...">StatisticInstance</a> / reports database records:</p>
<div class="fragment"><div class="line">simdb::DatabaseRoot * db_root = sim-&gt;getDatabaseRoot();</div>
<div class="line"> </div>
<div class="line">simdb::DatabaseNamespace * stats_namespace = db_root-&gt;</div>
<div class="line">    getNamespace(<span class="stringliteral">&quot;Stats&quot;</span>);</div>
<div class="line"> </div>
<div class="line">simdb::ObjectManager::ObjectDatabase * stats_db =</div>
<div class="line">    stats_namespace-&gt;getDatabase();</div>
</div><!-- fragment --><p>Once you have the ObjectDatabase for the desired namespace, access the table wrappers like so:</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;simdb::TableRef&gt; ts_table =</div>
<div class="line">    stats_db-&gt;getTable(<span class="stringliteral">&quot;Timeseries&quot;</span>);</div>
</div><!-- fragment --><p>See "simdb/include/simdb/schema/DatabaseRoot.hpp" and "simdb/include/simdb/ObjectManager.hpp" for more info about using these other classes to read and write database records in a SimDB namespace. </p>

</div>
</div>
<a id="aa54f06ff96e9de8f6cfdda48bc6f72d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54f06ff96e9de8f6cfdda48bc6f72d1">&#9670;&nbsp;</a></span>getRunControlInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sparta::control::TemporaryRunControl* sparta::app::Simulation::getRunControlInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the run control interface for this simulation. This must exist for the lifetime of this simulation. </p>
<p>This is overridable so that simulators can instantiate and return their own run control implementation. </p>

<p class="definition">Definition at line <a class="el" href="Simulation_8hpp_source.html#l00414">414</a> of file <a class="el" href="Simulation_8hpp_source.html">Simulation.hpp</a>.</p>

</div>
</div>
<a id="a55fef813ad97b712856fa4e1f91b193d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fef813ad97b712856fa4e1f91b193d">&#9670;&nbsp;</a></span>installTaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::Simulation::installTaps </td>
          <td>(</td>
          <td class="paramtype">const log::TapDescVec &amp;&#160;</td>
          <td class="paramname"><em>taps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add new taps the the simulation immediately IF possible. </p>
<dl class="section post"><dt>Postcondition</dt><dd>Warnings will be printed directly to cerr if any taps cannot be added. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>These taps cannot be removed and are not tracked like those added through <a class="el" href="classsparta_1_1app_1_1Simulation.html#a894a3af52b6ae904b529420c78f2873c" title="Configures the simulator after construction. Necessary only when using the simple constructor.">configure()</a> or the constructor.</dd></dl>
<p>This method exists mainly to allow delayed starting of logging </p>

</div>
</div>
<a id="ae5a2810562889b8eb9861d746dd7e982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a2810562889b8eb9861d746dd7e982">&#9670;&nbsp;</a></span>reapplyAllParameters_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::app::Simulation::reapplyAllParameters_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-read all parameter values from the virtual tree. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsparta_1_1app_1_1Simulation.html#abc20642aafe1eae610f620f40655c9a1" title="Re-read volatile parameter values from the virtual tree and write them to the parmeters....">reapplyVolatileParameters_</a> for precondition, return, and params </dd></dl>

</div>
</div>
<a id="abc20642aafe1eae610f620f40655c9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc20642aafe1eae610f620f40655c9a1">&#9670;&nbsp;</a></span>reapplyVolatileParameters_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::app::Simulation::reapplyVolatileParameters_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-read volatile parameter values from the virtual tree and write them to the parmeters. This is used by simulators if special parmeter application ordering is required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>Node at which a search for ParameterSets is started. Each <a class="el" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters.">ParameterSet</a> found as an ancestor of this node will have its volatile params updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not pass a <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> node directly as it will not be updated. </dd></dl>

</div>
</div>
<a id="a815cee822b7ca07fd569eae1f240ab07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815cee822b7ca07fd569eae1f240ab07">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sparta::app::Simulation::run </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>run_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run for specified "time" or less. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Device tree and framework must be finalized. and ensure finalizeFramework is called. Check <a class="el" href="classsparta_1_1app_1_1Simulation.html#a21ca4cbbb22bb5cfbd8c3838179796a5" title="Is the framework ready to run.">readyToRun()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">run_time</td><td>scheduler run_time argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Invokes runRaw_after setting up the dag. Catches exceptions from runRaw_ and outputs summary or debug dumps as necessary </dd></dl>

</div>
</div>
<a id="aa4e71a640813c8ba695a7d892cc4190b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e71a640813c8ba695a7d892cc4190b">&#9670;&nbsp;</a></span>runControlLoop_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sparta::app::Simulation::runControlLoop_ </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>run_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enter run-control loop causing the simulator to run or give control to an interactive shell. </p>
<dl class="section note"><dt>Note</dt><dd>Subclasses may override this method to provide custom state/setup or exception handling. This is called once per simulation lifetime. </dd>
<dd>
Exceptions generated within the model should be re-thrown up to the caller of this function so that SPARTA can properly log failures and quit with a proper exit. </dd></dl>

</div>
</div>
<a id="aae6aadfc529bfff578ff4ec17c032e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6aadfc529bfff578ff4ec17c032e83">&#9670;&nbsp;</a></span>runRaw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sparta::app::Simulation::runRaw </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>run_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs the simulation for a limited run time, returning when done. </p>
<p>This can be called multiple times for a simulator's lifetime and indicates a run of the simulator which can be interrupted by components within the simulator.</p>
<p>This should include no simulator-level setup code since it may be called multiple (unknown number of) times (never recursively) throughout the lifetime of the simulation.</p>
<p>By default, this is done through the SPARTA <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">Scheduler</a>. This method has no exception handling or setup. It should be overridden if the scheduler is not being used to run the simulation (e.g. simulation is functional-only and purely trace-driven). </p>

</div>
</div>
<a id="aa3c0bd7f205967b1732df4a2f7fcee24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c0bd7f205967b1732df4a2f7fcee24">&#9670;&nbsp;</a></span>runRaw_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sparta::app::Simulation::runRaw_ </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>run_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run for specified "time". </p>
<dl class="section pre"><dt>Precondition</dt><dd>Device tree and framework must be finalized. and ensure finalizeFramework is called. Check <a class="el" href="classsparta_1_1app_1_1Simulation.html#a21ca4cbbb22bb5cfbd8c3838179796a5" title="Is the framework ready to run.">readyToRun()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">run_time</td><td>scheduler run_time argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Invokes <a class="el" href="classsparta_1_1app_1_1Simulation.html#aa3c0bd7f205967b1732df4a2f7fcee24" title="Run for specified &quot;time&quot;.">runRaw_()</a> after setting up the dag. Catches exceptions from <a class="el" href="classsparta_1_1app_1_1Simulation.html#aa3c0bd7f205967b1732df4a2f7fcee24" title="Run for specified &quot;time&quot;.">runRaw_()</a> and outputs summary or debug dumps as necessary. </dd></dl>

</div>
</div>
<a id="a6ac09ce6f13aafb6dfb83780398bb6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac09ce6f13aafb6dfb83780398bb6e3">&#9670;&nbsp;</a></span>setFeatureConfig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::Simulation::setFeatureConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1app_1_1FeatureConfiguration.html">FeatureConfiguration</a> *&#160;</td>
          <td class="paramname"><em>feature_config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a collection of feature name-value pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature_config</td><td>Pointer to a feature configuration class</td></tr>
  </table>
  </dd>
</dl>
<p>Typically given to us by the <a class="el" href="classsparta_1_1app_1_1CommandLineSimulator.html" title="Command line simulator front-end class with argument parsing Works in conjunction with sparta::app::S...">CommandLineSimulator</a> who populates the feature values using a command-line "feature" option. </p>

<p class="definition">Definition at line <a class="el" href="Simulation_8hpp_source.html#l00110">110</a> of file <a class="el" href="Simulation_8hpp_source.html">Simulation.hpp</a>.</p>

</div>
</div>
<a id="a16f2cdb557bcd3d08a4d9c3193171ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f2cdb557bcd3d08a4d9c3193171ec1">&#9670;&nbsp;</a></span>setupStreamControllers_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::app::Simulation::setupStreamControllers_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If report statistics are being streamed out of this simulation, share the run controllers's stream controller object with each of the statistics stream root nodes. To illustrate: </p>
<p><a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">Simulation</a></p><ul>
<li>owns a RunController<ul>
<li><em>shares</em> a stream controller &lt;&ndash;|</li>
</ul>
</li>
<li>owns a ReportRepository |<ul>
<li>owns report / SI hierarchies |- make this connection<ul>
<li>each has a root StreamNode |<ul>
<li><em>shares</em> a stream controller &lt;&ndash;| </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a81b99477fa7a93af2839f755bfc9eb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b99477fa7a93af2839f755bfc9eb4b">&#9670;&nbsp;</a></span>usingPyshell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::app::Simulation::usingPyshell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Was this simulation configured with a Python shell? </p>
<dl class="section note"><dt>Note</dt><dd>Query this after <a class="el" href="classsparta_1_1app_1_1Simulation.html#a18ede64ec543df1bb56a71618fe82757" title="Finalize framework before running.">finalizeFramework()</a> is true. Configuration of the simulator can happen after construction but always before the simulation is built (buildTree_). While <a class="el" href="classsparta_1_1app_1_1Simulation.html#a18ede64ec543df1bb56a71618fe82757" title="Finalize framework before running.">finalizeFramework()</a> becomes true much later, it is a safe place to query. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Simulation_8hpp_source.html#l00399">399</a> of file <a class="el" href="Simulation_8hpp_source.html">Simulation.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aeb97c8691a2c5f6faec19a4022e9a24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb97c8691a2c5f6faec19a4022e9a24b">&#9670;&nbsp;</a></span>meta_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsparta_1_1app_1_1MetaTreeNode.html">MetaTreeNode</a>&gt; sparta::app::Simulation::meta_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Meta-tree containing simulation meta-information in parameters in "meta.params.fizbin". Destruct after all non-root nodes (see to_delete_) </p>
<dl class="section note"><dt>Note</dt><dd>Created after parameter preprocessing since it has some parameters of its own. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Simulation_8hpp_source.html#l00807">807</a> of file <a class="el" href="Simulation_8hpp_source.html">Simulation.hpp</a>.</p>

</div>
</div>
<a id="af82f9aa9ab35c34c8adaa911e8813221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82f9aa9ab35c34c8adaa911e8813221">&#9670;&nbsp;</a></span>user_configs_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classsparta_1_1app_1_1ConfigApplicator.html">ConfigApplicator</a>*&gt; sparta::app::Simulation::user_configs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User configuration vector stored at "preprocessParameters". </p>
<dl class="section note"><dt>Note</dt><dd>Does not own memory. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Simulation_8hpp_source.html#l00887">887</a> of file <a class="el" href="Simulation_8hpp_source.html">Simulation.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/sparta/sparta/app/<a class="el" href="Simulation_8hpp_source.html">Simulation.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li><li class="navelem"><a class="el" href="namespacesparta_1_1app.html">app</a></li><li class="navelem"><a class="el" href="classsparta_1_1app_1_1Simulation.html">Simulation</a></li>
    <li class="footer">Generated on Fri Sep 25 2020 04:28:31 for The Sparta Modeling Framework by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
