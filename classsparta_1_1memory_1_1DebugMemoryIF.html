<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta::memory::DebugMemoryIF Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classsparta_1_1memory_1_1DebugMemoryIF.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classsparta_1_1memory_1_1DebugMemoryIF-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sparta::memory::DebugMemoryIF Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Memory interface which represents a simple, immediately accessible (blocking) address-space with support for peek and poke acceeses having no side effects other than changing the desired memory.  
 <a href="classsparta_1_1memory_1_1DebugMemoryIF.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DebugMemoryIF_8hpp_source.html">DebugMemoryIF.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sparta::memory::DebugMemoryIF:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1DebugMemoryIF__inherit__graph.png" border="0" usemap="#asparta_1_1memory_1_1DebugMemoryIF_inherit__map" alt="Inheritance graph"/></div>
<map name="sparta_1_1memory_1_1DebugMemoryIF_inherit__map" id="asparta_1_1memory_1_1DebugMemoryIF_inherit__map">
<area shape="rect" title="Memory interface which represents a simple, immediately accessible (blocking) address&#45;space with supp..." alt="" coords="5,110,216,137"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure&#45;virtual memory interface which represents a simple, immediately accessible (blocking) address&#45;sp..." alt="" coords="264,103,431,144"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIFNode.html" title="Pure&#45;virtual memory interface that builds on the BlockingMemoryIF, acting as a TreeNode in the SPARTA..." alt="" coords="491,37,657,79"/>
<area shape="rect" href="classsparta_1_1memory_1_1DMI__DEPRECATED.html" title="Defines a DMI which can be used as a fast memory interface that writes directly to a raw pointer." alt="" coords="504,103,644,144"/>
<area shape="rect" href="classsparta_1_1memory_1_1DMIBlockingMemoryIF.html" title="Wrapps a DMI in a BlockingMemoryIF." alt="" coords="479,168,669,209"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryObjectIFNode.html" title="BlockingMemoryIFNode implementation with binding to a MemoryObject instantiated separately and specif..." alt="" coords="735,5,902,47"/>
<area shape="rect" href="classsparta_1_1memory_1_1SimpleMemoryMapNode.html" title="Memory mapping object which implements BlockingMemoryIFNode. Supports a simple mapping of incoming ad..." alt="" coords="717,71,920,112"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sparta::memory::DebugMemoryIF:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1DebugMemoryIF__coll__graph.png" border="0" usemap="#asparta_1_1memory_1_1DebugMemoryIF_coll__map" alt="Collaboration graph"/></div>
<map name="sparta_1_1memory_1_1DebugMemoryIF_coll__map" id="asparta_1_1memory_1_1DebugMemoryIF_coll__map">
<area shape="rect" title="Memory interface which represents a simple, immediately accessible (blocking) address&#45;space with supp..." alt="" coords="5,95,216,121"/>
<area shape="rect" href="classsparta_1_1memory_1_1TranslationIF.html" title="Blocking translation interface with 1:1 translation unless subclassed." alt="" coords="15,5,207,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">AccessWindow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an access window within this interface. Accesses through a memory interface are constrained to this window.  <a href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:ae47924af1683c0df0d0521b661c051a6"><td class="memItemLeft" align="right" valign="top"><a id="ae47924af1683c0df0d0521b661c051a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ae47924af1683c0df0d0521b661c051a6">DebugMemoryIF</a> ()=delete</td></tr>
<tr class="memdesc:ae47924af1683c0df0d0521b661c051a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constuctor. <br /></td></tr>
<tr class="separator:ae47924af1683c0df0d0521b661c051a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216bb8e3ff6974157a2a792408bc4314"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a216bb8e3ff6974157a2a792408bc4314">DebugMemoryIF</a> (const std::string &amp;desc, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> block_size, const <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">AccessWindow</a> &amp;window, <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *transif=nullptr)</td></tr>
<tr class="memdesc:a216bb8e3ff6974157a2a792408bc4314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a DebugMemoryInterface.  <a href="classsparta_1_1memory_1_1DebugMemoryIF.html#a216bb8e3ff6974157a2a792408bc4314">More...</a><br /></td></tr>
<tr class="separator:a216bb8e3ff6974157a2a792408bc4314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc718c72432a36e9271ca56511f911c"><td class="memItemLeft" align="right" valign="top"><a id="a0bc718c72432a36e9271ca56511f911c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a0bc718c72432a36e9271ca56511f911c">~DebugMemoryIF</a> ()</td></tr>
<tr class="memdesc:a0bc718c72432a36e9271ca56511f911c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virutal destructor. <br /></td></tr>
<tr class="separator:a0bc718c72432a36e9271ca56511f911c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Translation Information</div></td></tr>
<tr class="memitem:a5a2e70187119dcae3d5c39b480fd6d36"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a5a2e70187119dcae3d5c39b480fd6d36">getTranslationIF</a> ()</td></tr>
<tr class="memdesc:a5a2e70187119dcae3d5c39b480fd6d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the translation interface associated with this Debug memory interface (if any).  <a href="classsparta_1_1memory_1_1DebugMemoryIF.html#a5a2e70187119dcae3d5c39b480fd6d36">More...</a><br /></td></tr>
<tr class="separator:a5a2e70187119dcae3d5c39b480fd6d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Interface Attributes</div></td></tr>
<tr class="memitem:adcece0745e1ffcc6262c7c85d9788e4b"><td class="memItemLeft" align="right" valign="top"><a id="adcece0745e1ffcc6262c7c85d9788e4b"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#adcece0745e1ffcc6262c7c85d9788e4b">getDescription</a> ()</td></tr>
<tr class="memdesc:adcece0745e1ffcc6262c7c85d9788e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description specified at construction. <br /></td></tr>
<tr class="separator:adcece0745e1ffcc6262c7c85d9788e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec5c7bd3d39673eacfea9c54341d768"><td class="memItemLeft" align="right" valign="top"><a id="afec5c7bd3d39673eacfea9c54341d768"></a>
<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#afec5c7bd3d39673eacfea9c54341d768">getBlockSize</a> () const</td></tr>
<tr class="memdesc:afec5c7bd3d39673eacfea9c54341d768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the block size of memory represented by this interface. Read and write accesses must not span block boundaries (where addr % block_size == 0). <br /></td></tr>
<tr class="separator:afec5c7bd3d39673eacfea9c54341d768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88eaaf49740910933179b3b489e10c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a88eaaf49740910933179b3b489e10c41">getRange</a> () const</td></tr>
<tr class="memdesc:a88eaaf49740910933179b3b489e10c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total span of this interface's valid address range.  <a href="classsparta_1_1memory_1_1DebugMemoryIF.html#a88eaaf49740910933179b3b489e10c41">More...</a><br /></td></tr>
<tr class="separator:a88eaaf49740910933179b3b489e10c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813c0abcfcf0f1da307c0fe66eaead12"><td class="memItemLeft" align="right" valign="top"><a id="a813c0abcfcf0f1da307c0fe66eaead12"></a>
<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a813c0abcfcf0f1da307c0fe66eaead12">getLowEnd</a> () const</td></tr>
<tr class="memdesc:a813c0abcfcf0f1da307c0fe66eaead12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lowest address accessible. <br /></td></tr>
<tr class="separator:a813c0abcfcf0f1da307c0fe66eaead12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619defc758b28691ce97c4e37f8d232d"><td class="memItemLeft" align="right" valign="top"><a id="a619defc758b28691ce97c4e37f8d232d"></a>
<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a619defc758b28691ce97c4e37f8d232d">getHighEnd</a> () const</td></tr>
<tr class="memdesc:a619defc758b28691ce97c4e37f8d232d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the highest address accessible + 1. <br /></td></tr>
<tr class="separator:a619defc758b28691ce97c4e37f8d232d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bafb07c039aab8148305aefc68c578"><td class="memItemLeft" align="right" valign="top"><a id="a60bafb07c039aab8148305aefc68c578"></a>
<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a60bafb07c039aab8148305aefc68c578">getAccessibleSize</a> () const</td></tr>
<tr class="memdesc:a60bafb07c039aab8148305aefc68c578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total accessible size of this interface's valid addresses within the total size (getRange) excluding holes between access windows. <br /></td></tr>
<tr class="separator:a60bafb07c039aab8148305aefc68c578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbb5da4470297b3266936a154adf963"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">AccessWindow</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#addbb5da4470297b3266936a154adf963">getWindows</a> () const</td></tr>
<tr class="memdesc:addbb5da4470297b3266936a154adf963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vector of windows representing this interface.  <a href="classsparta_1_1memory_1_1DebugMemoryIF.html#addbb5da4470297b3266936a154adf963">More...</a><br /></td></tr>
<tr class="separator:addbb5da4470297b3266936a154adf963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">General Queries</div></td></tr>
<tr class="memitem:ab1237a04a9fdfb296be4dc712fddbd0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ab1237a04a9fdfb296be4dc712fddbd0e">isAddressInWindows</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr) const noexcept</td></tr>
<tr class="memdesc:ab1237a04a9fdfb296be4dc712fddbd0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given address is in an access window defined for this interface.  <a href="classsparta_1_1memory_1_1DebugMemoryIF.html#ab1237a04a9fdfb296be4dc712fddbd0e">More...</a><br /></td></tr>
<tr class="separator:ab1237a04a9fdfb296be4dc712fddbd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35fa48697f197f9357be0d6c5fae0c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ae35fa48697f197f9357be0d6c5fae0c6">verifyInAccessWindows</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const</td></tr>
<tr class="memdesc:ae35fa48697f197f9357be0d6c5fae0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the range [addr, addr+size) is within the access windows for this interface.  <a href="classsparta_1_1memory_1_1DebugMemoryIF.html#ae35fa48697f197f9357be0d6c5fae0c6">More...</a><br /></td></tr>
<tr class="separator:ae35fa48697f197f9357be0d6c5fae0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bff166f0c2e250be9450a8a152becc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a56bff166f0c2e250be9450a8a152becc">isInAccessWindows</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const</td></tr>
<tr class="memdesc:a56bff166f0c2e250be9450a8a152becc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the range [addr, addr+size) is within the access windows for this interface.  <a href="classsparta_1_1memory_1_1DebugMemoryIF.html#a56bff166f0c2e250be9450a8a152becc">More...</a><br /></td></tr>
<tr class="separator:a56bff166f0c2e250be9450a8a152becc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb92bd2905d208cab60935b46dcd67a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#acb92bd2905d208cab60935b46dcd67a9">verifyNoBlockSpan</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const</td></tr>
<tr class="memdesc:acb92bd2905d208cab60935b46dcd67a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the given address does not span block boundaries defined for this interface.  <a href="classsparta_1_1memory_1_1DebugMemoryIF.html#acb92bd2905d208cab60935b46dcd67a9">More...</a><br /></td></tr>
<tr class="separator:acb92bd2905d208cab60935b46dcd67a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efd1a8b860fd5224a78b4f17f06853d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a4efd1a8b860fd5224a78b4f17f06853d">doesAccessSpan</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const noexcept</td></tr>
<tr class="memdesc:a4efd1a8b860fd5224a78b4f17f06853d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given address spans block boundaries defined for this interface. Accesses which span blocks are illegal for read/write accesses, but allowed for peak/poke debug accesses.  <a href="classsparta_1_1memory_1_1DebugMemoryIF.html#a4efd1a8b860fd5224a78b4f17f06853d">More...</a><br /></td></tr>
<tr class="separator:a4efd1a8b860fd5224a78b4f17f06853d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Debug Memory Access</div></td></tr>
<tr class="memitem:a1d460c6428bfcb6d1e37b3b908f17eef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a1d460c6428bfcb6d1e37b3b908f17eef">tryPeek</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, uint8_t *buf) const</td></tr>
<tr class="memdesc:a1d460c6428bfcb6d1e37b3b908f17eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to 'peek' memory without having any side effects, size-limitations, alignment constraints except that all bytes peeked are inside an access window for this interface.  <a href="classsparta_1_1memory_1_1DebugMemoryIF.html#a1d460c6428bfcb6d1e37b3b908f17eef">More...</a><br /></td></tr>
<tr class="separator:a1d460c6428bfcb6d1e37b3b908f17eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af806a7b9bf291eb5e1ae1311e70398f2"><td class="memItemLeft" align="right" valign="top"><a id="af806a7b9bf291eb5e1ae1311e70398f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#af806a7b9bf291eb5e1ae1311e70398f2">peek</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, uint8_t *buf) const</td></tr>
<tr class="memdesc:af806a7b9bf291eb5e1ae1311e70398f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper on tryPeek which throws a <a class="el" href="classsparta_1_1memory_1_1MemoryAccessError.html" title="Indicates that there was an issue accessing a SPARTA memory object or interface.">MemoryAccessError</a> if the peek is not legal. <br /></td></tr>
<tr class="separator:af806a7b9bf291eb5e1ae1311e70398f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca95f6e332e2c05d78fa5c08ff73965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#afca95f6e332e2c05d78fa5c08ff73965">tryPoke</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf)</td></tr>
<tr class="memdesc:afca95f6e332e2c05d78fa5c08ff73965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to 'poke' memory without having any side effects other than changing the bytes within the range [ <em>addr</em> , <em>addr</em> + <em>size</em> ). Poke has no size-limitations or alignment constraints except that all bytes peeked are inside an access window for this interface.  <a href="classsparta_1_1memory_1_1DebugMemoryIF.html#afca95f6e332e2c05d78fa5c08ff73965">More...</a><br /></td></tr>
<tr class="separator:afca95f6e332e2c05d78fa5c08ff73965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d6378acc3c8737db0f6416b8082df"><td class="memItemLeft" align="right" valign="top"><a id="abb5d6378acc3c8737db0f6416b8082df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#abb5d6378acc3c8737db0f6416b8082df">poke</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf)</td></tr>
<tr class="memdesc:abb5d6378acc3c8737db0f6416b8082df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper on tryPoke which throws a <a class="el" href="classsparta_1_1memory_1_1MemoryAccessError.html" title="Indicates that there was an issue accessing a SPARTA memory object or interface.">MemoryAccessError</a> if the poke is not legal. <br /></td></tr>
<tr class="separator:abb5d6378acc3c8737db0f6416b8082df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a65c02153d3a5600ccd331c8888aa99b5"><td class="memItemLeft" align="right" valign="top"><a id="a65c02153d3a5600ccd331c8888aa99b5"></a>
const <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a65c02153d3a5600ccd331c8888aa99b5">block_size_</a></td></tr>
<tr class="memdesc:a65c02153d3a5600ccd331c8888aa99b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a block accessed through this interface. <br /></td></tr>
<tr class="separator:a65c02153d3a5600ccd331c8888aa99b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3017884c6a75c3c142c996bc621e68"><td class="memItemLeft" align="right" valign="top"><a id="a7a3017884c6a75c3c142c996bc621e68"></a>
<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a7a3017884c6a75c3c142c996bc621e68">block_mask_</a></td></tr>
<tr class="memdesc:a7a3017884c6a75c3c142c996bc621e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask applied to an address to get only bits representing the block ID. <br /></td></tr>
<tr class="separator:a7a3017884c6a75c3c142c996bc621e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ca96578aee4568ca9f7f65d97f8622"><td class="memItemLeft" align="right" valign="top"><a id="ac8ca96578aee4568ca9f7f65d97f8622"></a>
<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ac8ca96578aee4568ca9f7f65d97f8622">block_idx_lsb_</a></td></tr>
<tr class="memdesc:ac8ca96578aee4568ca9f7f65d97f8622"><td class="mdescLeft">&#160;</td><td class="mdescRight">rshift applied to an address to get the block ID <br /></td></tr>
<tr class="separator:ac8ca96578aee4568ca9f7f65d97f8622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3ebb4e5d6568ef4cf7ed73c4b3efb5"><td class="memItemLeft" align="right" valign="top"><a id="aed3ebb4e5d6568ef4cf7ed73c4b3efb5"></a>
const std::vector&lt; <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">AccessWindow</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#aed3ebb4e5d6568ef4cf7ed73c4b3efb5">acc_windows_</a></td></tr>
<tr class="memdesc:aed3ebb4e5d6568ef4cf7ed73c4b3efb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of access windows representing this memory. <br /></td></tr>
<tr class="separator:aed3ebb4e5d6568ef4cf7ed73c4b3efb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76ed77db27ed4a7c3c08d75a965faf6"><td class="memItemLeft" align="right" valign="top"><a id="aa76ed77db27ed4a7c3c08d75a965faf6"></a>
<a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#aa76ed77db27ed4a7c3c08d75a965faf6">trans_</a></td></tr>
<tr class="memdesc:aa76ed77db27ed4a7c3c08d75a965faf6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1memory_1_1Translation.html" title="An older class used to help in encapsulate read/virtual addresses.">Translation</a> interface created for this interface. Externally owned. <br /></td></tr>
<tr class="separator:aa76ed77db27ed4a7c3c08d75a965faf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2182d932a817fceab277b60492a5203"><td class="memItemLeft" align="right" valign="top"><a id="ad2182d932a817fceab277b60492a5203"></a>
const std::string *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ad2182d932a817fceab277b60492a5203">desc_ptr_</a></td></tr>
<tr class="memdesc:ad2182d932a817fceab277b60492a5203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description pointer. <br /></td></tr>
<tr class="separator:ad2182d932a817fceab277b60492a5203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c0a329c864f37b5021277ce4349dc0"><td class="memItemLeft" align="right" valign="top"><a id="a64c0a329c864f37b5021277ce4349dc0"></a>
<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a64c0a329c864f37b5021277ce4349dc0">total_range_</a></td></tr>
<tr class="memdesc:a64c0a329c864f37b5021277ce4349dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of addresses from highest accessible to lowest. <br /></td></tr>
<tr class="separator:a64c0a329c864f37b5021277ce4349dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece4fca05034cac697a447f391027fbf"><td class="memItemLeft" align="right" valign="top"><a id="aece4fca05034cac697a447f391027fbf"></a>
<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#aece4fca05034cac697a447f391027fbf">low_end_</a></td></tr>
<tr class="memdesc:aece4fca05034cac697a447f391027fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowest accessible address. <br /></td></tr>
<tr class="separator:aece4fca05034cac697a447f391027fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cbfa9ae6babb7e56cdc56366a3ae33"><td class="memItemLeft" align="right" valign="top"><a id="a11cbfa9ae6babb7e56cdc56366a3ae33"></a>
<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a11cbfa9ae6babb7e56cdc56366a3ae33">high_end_</a></td></tr>
<tr class="memdesc:a11cbfa9ae6babb7e56cdc56366a3ae33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highest accessible address + 1. <br /></td></tr>
<tr class="separator:a11cbfa9ae6babb7e56cdc56366a3ae33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616fca295fada16fa14ec939588265be"><td class="memItemLeft" align="right" valign="top"><a id="a616fca295fada16fa14ec939588265be"></a>
<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a616fca295fada16fa14ec939588265be">accessible_size_</a></td></tr>
<tr class="memdesc:a616fca295fada16fa14ec939588265be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes accessible through this interface. <br /></td></tr>
<tr class="separator:a616fca295fada16fa14ec939588265be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Memory interface which represents a simple, immediately accessible (blocking) address-space with support for peek and poke acceeses having no side effects other than changing the desired memory. </p>
<p>This interface does not support non-blocking accesses or access attributes.</p>
<p>This interface operates on post-translated addresses from the <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html" title="Blocking translation interface with 1:1 translation unless subclassed.">TranslationIF</a> available through getTranslationIF</p>
<p>The object implementing this interface can perform any translation or logic to satisfy memory accesses.</p>
<p>Peek and Poke accesses within this interface are automatically chunked into block-constrained accesses and re-assembled.</p>
<p>This class is intended to be an innocuous interface to some kind of "memory" from the perspective of some simulation unit with which this interface is associated. For example, if attached to a core this interface would most appropriately present the software view of virtual memory. Note that data and instruction memory views from a core may need to use different debugging interfaces. It is possible different interfaces could even be provided for each address-space avaialable per data and instruction depending on that core's mmu.</p>
<p>Example </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespacesparta_1_1memory.html">sparta::memory</a>;</div>
<div class="line"><span class="comment">// DebugMemoryIF* dbgmi;</span></div>
<div class="line"><span class="comment">// addr_t varrd;</span></div>
<div class="line"><span class="comment">// const uint8_t data[4];</span></div>
<div class="line"><span class="comment">// uint8_t buf[4];</span></div>
<div class="line"><a class="code" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> paddr = dbgmi-&gt;getTranslationIF()-&gt;translate(vaddr);</div>
<div class="line">dbgmi-&gt;poke(paddr, 4, data);</div>
<div class="line">dbgmi-&gt;peek(paddr, 4, buf);</div>
<div class="line"><span class="comment">// Note: Translation is only required if the interface does not</span></div>
<div class="line"><span class="comment">// represent direct access to physical memory</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="DebugMemoryIF_8hpp_source.html#l00064">64</a> of file <a class="el" href="DebugMemoryIF_8hpp_source.html">DebugMemoryIF.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a216bb8e3ff6974157a2a792408bc4314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216bb8e3ff6974157a2a792408bc4314">&#9670;&nbsp;</a></span>DebugMemoryIF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparta::memory::DebugMemoryIF::DebugMemoryIF </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">AccessWindow</a> &amp;&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *&#160;</td>
          <td class="paramname"><em>transif</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a DebugMemoryInterface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Description of this interface. What is this an interface for and what is the perspective? For example, "core virtual data memory". This exists so that errors generated by this code can indicate which interface the error came from </td></tr>
    <tr><td class="paramname">block_size</td><td>Size of a block in this interface. Must be a power of 2 and greater than 0. </td></tr>
    <tr><td class="paramname">window</td><td><a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html" title="Defines an access window within this interface. Accesses through a memory interface are constrained t...">AccessWindow</a> defining valid range of addresses. Must be block-aligned. These are post-translated addresses ready to be used in access methods </td></tr>
    <tr><td class="paramname">transif</td><td>Optional translation interface associated with this memory interface. This must be specified, is managed externally, and must exist for the lifetime of this interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if <em>block_size</em> or <em>window</em> is invalid </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000048">Todo:</a></b></dt><dd>Support vectors of windows with holes </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000049">Todo:</a></b></dt><dd>Check for access window overlaps (once multiple windows are supported) </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000050">Todo:</a></b></dt><dd>Create lookup map for identifying holes if more than 1 window is allowed </dd></dl>

<p class="definition">Definition at line <a class="el" href="DebugMemoryIF_8hpp_source.html#l00163">163</a> of file <a class="el" href="DebugMemoryIF_8hpp_source.html">DebugMemoryIF.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4efd1a8b860fd5224a78b4f17f06853d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efd1a8b860fd5224a78b4f17f06853d">&#9670;&nbsp;</a></span>doesAccessSpan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::memory::DebugMemoryIF::doesAccessSpan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given address spans block boundaries defined for this interface. Accesses which span blocks are illegal for read/write accesses, but allowed for peak/poke debug accesses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Post-translated address to test (see getTranslationIF) </td></tr>
    <tr><td class="paramname">size</td><td>Size of access to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if access spans a block boundary, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="DebugMemoryIF_8hpp_source.html#l00394">394</a> of file <a class="el" href="DebugMemoryIF_8hpp_source.html">DebugMemoryIF.hpp</a>.</p>

</div>
</div>
<a id="a88eaaf49740910933179b3b489e10c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88eaaf49740910933179b3b489e10c41">&#9670;&nbsp;</a></span>getRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> sparta::memory::DebugMemoryIF::getRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the total span of this interface's valid address range. </p>
<p>This is: 1 + the highest accessible address - the lowest accessible address. </p>

<p class="definition">Definition at line <a class="el" href="DebugMemoryIF_8hpp_source.html#l00283">283</a> of file <a class="el" href="DebugMemoryIF_8hpp_source.html">DebugMemoryIF.hpp</a>.</p>

</div>
</div>
<a id="a5a2e70187119dcae3d5c39b480fd6d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2e70187119dcae3d5c39b480fd6d36">&#9670;&nbsp;</a></span>getTranslationIF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a>* sparta::memory::DebugMemoryIF::getTranslationIF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the translation interface associated with this Debug memory interface (if any). </p>
<p>This translation interface, if not nullptr, is intended to be used by a client of this class to translate addresses from some external space into a space suitable for use in memory accesses through this interface.</p>
<p>The <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html" title="Memory interface which represents a simple, immediately accessible (blocking) address-space with supp...">DebugMemoryIF</a> does not use this translation interface. This association is present as a hint for toos and UIs. </p>

<p class="definition">Definition at line <a class="el" href="DebugMemoryIF_8hpp_source.html#l00253">253</a> of file <a class="el" href="DebugMemoryIF_8hpp_source.html">DebugMemoryIF.hpp</a>.</p>

</div>
</div>
<a id="addbb5da4470297b3266936a154adf963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbb5da4470297b3266936a154adf963">&#9670;&nbsp;</a></span>getWindows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">AccessWindow</a>&gt;&amp; sparta::memory::DebugMemoryIF::getWindows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the vector of windows representing this interface. </p>
<p>These windows define the post-translated access space for this interface </p>

<p class="definition">Definition at line <a class="el" href="DebugMemoryIF_8hpp_source.html#l00308">308</a> of file <a class="el" href="DebugMemoryIF_8hpp_source.html">DebugMemoryIF.hpp</a>.</p>

</div>
</div>
<a id="ab1237a04a9fdfb296be4dc712fddbd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1237a04a9fdfb296be4dc712fddbd0e">&#9670;&nbsp;</a></span>isAddressInWindows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::memory::DebugMemoryIF::isAddressInWindows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given address is in an access window defined for this interface. </p>
<dl class="section return"><dt>Returns</dt><dd>true if in some window, false otherwise </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is not a high-performance method. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>verifyInAccessWindows_ </dd></dl>

<p class="definition">Definition at line <a class="el" href="DebugMemoryIF_8hpp_source.html#l00326">326</a> of file <a class="el" href="DebugMemoryIF_8hpp_source.html">DebugMemoryIF.hpp</a>.</p>

</div>
</div>
<a id="a56bff166f0c2e250be9450a8a152becc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56bff166f0c2e250be9450a8a152becc">&#9670;&nbsp;</a></span>isInAccessWindows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::memory::DebugMemoryIF::isInAccessWindows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the range [addr, addr+size) is within the access windows for this interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Post-translated address to test (see getTranslationIF) </td></tr>
    <tr><td class="paramname">size</td><td>Size of access to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if access does not fall entirely within access windows of this interface </dd></dl>

<p class="definition">Definition at line <a class="el" href="DebugMemoryIF_8hpp_source.html#l00363">363</a> of file <a class="el" href="DebugMemoryIF_8hpp_source.html">DebugMemoryIF.hpp</a>.</p>

</div>
</div>
<a id="a1d460c6428bfcb6d1e37b3b908f17eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d460c6428bfcb6d1e37b3b908f17eef">&#9670;&nbsp;</a></span>tryPeek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::memory::DebugMemoryIF::tryPeek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to 'peek' memory without having any side effects, size-limitations, alignment constraints except that all bytes peeked are inside an access window for this interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Post-translated address from which to peek (see getTranslationIF) </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to read from <em>buf</em>. Note that <em>addr</em> and <em>size</em> can span block boundaries in a peek/poke method </td></tr>
    <tr><td class="paramname">buf</td><td><a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> to which <em>size</em> peeked bytes will be copied if the peek was legal. Content of <em>buf</em> is undefined if peek is illegal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the peek is legal and false if not. It is up to the caller to determine if the <em>addr</em> and <em>size</em> are legal values for this interface (i.e. in an access window and not spanning a block boundary). Further restriction on alignment may be imposed by the implementation but generally should not be. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Has NO side-effects on simulation. Simply gets data if possible. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Peek is a const-qualified method and is thus allowed in const instances of <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html" title="Memory interface which represents a simple, immediately accessible (blocking) address-space with supp...">DebugMemoryIF</a> to provide clients with read-onlydebug access to memory </dd>
<dd>
Peeking has no performance requirements and may be slower than read.</dd></dl>
<p>Peeking is intended as a debugger/tool interface to the simulation </p>

<p class="definition">Definition at line <a class="el" href="DebugMemoryIF_8hpp_source.html#l00432">432</a> of file <a class="el" href="DebugMemoryIF_8hpp_source.html">DebugMemoryIF.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1DebugMemoryIF_a1d460c6428bfcb6d1e37b3b908f17eef_cgraph.png" border="0" usemap="#aclasssparta_1_1memory_1_1DebugMemoryIF_a1d460c6428bfcb6d1e37b3b908f17eef_cgraph" alt=""/></div>
<map name="classsparta_1_1memory_1_1DebugMemoryIF_a1d460c6428bfcb6d1e37b3b908f17eef_cgraph" id="aclasssparta_1_1memory_1_1DebugMemoryIF_a1d460c6428bfcb6d1e37b3b908f17eef_cgraph">
<area shape="rect" title="Attempts to &#39;peek&#39; memory without having any side effects, size&#45;limitations, alignment constraints ex..." alt="" coords="5,5,204,47"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a56bff166f0c2e250be9450a8a152becc" title="Determines if the range [addr, addr+size) is within the access windows for this interface." alt="" coords="252,5,451,47"/>
</map>
</div>

</div>
</div>
<a id="afca95f6e332e2c05d78fa5c08ff73965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca95f6e332e2c05d78fa5c08ff73965">&#9670;&nbsp;</a></span>tryPoke()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::memory::DebugMemoryIF::tryPoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to 'poke' memory without having any side effects other than changing the bytes within the range [ <em>addr</em> , <em>addr</em> + <em>size</em> ). Poke has no size-limitations or alignment constraints except that all bytes peeked are inside an access window for this interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Post-translated address to which to poke (see getTranslationIF) </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to write from <em>buf</em>. Note that <em>addr</em> and <em>size</em> can span block boundaries in a peek/poke method </td></tr>
    <tr><td class="paramname">buf</td><td>read-only buffer whose content should be written to memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the poke is legal and false if not. It is up to the caller to determine if the <em>addr</em> and <em>size</em> are legal values for this interface (i.e. in an access window and not spanning a block boundary). Further restriction on alignment may be imposed by the implementation but generally should not be. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Memory state will reflect the bytes poked. </dd>
<dd>
Data in memory is not expected to be modified upon an illegal poke </dd>
<dd>
Has NO side-effects on simulation but can modify memory storage. Has the effect of simply replacing the specified bytes in the memory model storage. The model storage internal data structures (e.g. sprarse mapping, checkpointing helpers, etc) can be modified to support a poke (i.e. a new block needed allocation) if it is required to store the poked data. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Poking has no performance requirements and may be slower than write.</dd></dl>
<p>Poking is intended as a debugger/tool interface to the simulation </p>

<p class="definition">Definition at line <a class="el" href="DebugMemoryIF_8hpp_source.html#l00502">502</a> of file <a class="el" href="DebugMemoryIF_8hpp_source.html">DebugMemoryIF.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1DebugMemoryIF_afca95f6e332e2c05d78fa5c08ff73965_cgraph.png" border="0" usemap="#aclasssparta_1_1memory_1_1DebugMemoryIF_afca95f6e332e2c05d78fa5c08ff73965_cgraph" alt=""/></div>
<map name="classsparta_1_1memory_1_1DebugMemoryIF_afca95f6e332e2c05d78fa5c08ff73965_cgraph" id="aclasssparta_1_1memory_1_1DebugMemoryIF_afca95f6e332e2c05d78fa5c08ff73965_cgraph">
<area shape="rect" title="Attempts to &#39;poke&#39; memory without having any side effects other than changing the bytes within the ra..." alt="" coords="5,5,204,47"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a56bff166f0c2e250be9450a8a152becc" title="Determines if the range [addr, addr+size) is within the access windows for this interface." alt="" coords="252,5,451,47"/>
</map>
</div>

</div>
</div>
<a id="ae35fa48697f197f9357be0d6c5fae0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35fa48697f197f9357be0d6c5fae0c6">&#9670;&nbsp;</a></span>verifyInAccessWindows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::memory::DebugMemoryIF::verifyInAccessWindows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifies that the range [addr, addr+size) is within the access windows for this interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Post-translated address to which to test (see getTranslationIF) </td></tr>
    <tr><td class="paramname">size</td><td>Size of access to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1memory_1_1MemoryAccessError.html" title="Indicates that there was an issue accessing a SPARTA memory object or interface.">MemoryAccessError</a></td><td>if the access is not entirely contained in access windows. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="DebugMemoryIF_8hpp_source.html#l00344">344</a> of file <a class="el" href="DebugMemoryIF_8hpp_source.html">DebugMemoryIF.hpp</a>.</p>

</div>
</div>
<a id="acb92bd2905d208cab60935b46dcd67a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb92bd2905d208cab60935b46dcd67a9">&#9670;&nbsp;</a></span>verifyNoBlockSpan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::memory::DebugMemoryIF::verifyNoBlockSpan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifies that the given address does not span block boundaries defined for this interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Post-translated address to test (see getTranslationIF) </td></tr>
    <tr><td class="paramname">size</td><td>Size of access to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1memory_1_1MemoryAccessError.html" title="Indicates that there was an issue accessing a SPARTA memory object or interface.">MemoryAccessError</a></td><td>if true if access spans a block boundary, false otherwise </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="DebugMemoryIF_8hpp_source.html#l00377">377</a> of file <a class="el" href="DebugMemoryIF_8hpp_source.html">DebugMemoryIF.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1DebugMemoryIF_acb92bd2905d208cab60935b46dcd67a9_cgraph.png" border="0" usemap="#aclasssparta_1_1memory_1_1DebugMemoryIF_acb92bd2905d208cab60935b46dcd67a9_cgraph" alt=""/></div>
<map name="classsparta_1_1memory_1_1DebugMemoryIF_acb92bd2905d208cab60935b46dcd67a9_cgraph" id="aclasssparta_1_1memory_1_1DebugMemoryIF_acb92bd2905d208cab60935b46dcd67a9_cgraph">
<area shape="rect" title="Verifies that the given address does not span block boundaries defined for this interface." alt="" coords="5,5,204,47"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a4efd1a8b860fd5224a78b4f17f06853d" title="Determines if the given address spans block boundaries defined for this interface...." alt="" coords="252,5,451,47"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/sparta/sparta/memory/<a class="el" href="DebugMemoryIF_8hpp_source.html">DebugMemoryIF.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacesparta_1_1memory_html_abf087efa080d7cc51647e4920b42a401"><div class="ttname"><a href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">sparta::memory::addr_t</a></div><div class="ttdeci">uint64_t addr_t</div><div class="ttdoc">Type for generic address representation in generic interfaces, errors and printouts within SPARTA.</div><div class="ttdef"><b>Definition:</b> <a href="AddressTypes_8hpp_source.html#l00024">AddressTypes.hpp:24</a></div></div>
<div class="ttc" id="anamespacesparta_1_1memory_html"><div class="ttname"><a href="namespacesparta_1_1memory.html">sparta::memory</a></div><div class="ttdoc">Namespace containing memory interfaces, types, and storage objects.</div><div class="ttdef"><b>Definition:</b> <a href="AddressTypes_8hpp_source.html#l00018">AddressTypes.hpp:19</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li><li class="navelem"><a class="el" href="namespacesparta_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html">DebugMemoryIF</a></li>
    <li class="footer">Generated on Fri Sep 25 2020 04:28:32 for The Sparta Modeling Framework by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
