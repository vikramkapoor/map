<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta::ParameterTree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classsparta_1_1ParameterTree.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsparta_1_1ParameterTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sparta::ParameterTree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Virtual <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> Tree. This represents a tree of parameters read from some source but does not necessarily correspond to the parameters in the simulation itself or even to the simulation tree. This is meant to provide a hierarchical view into simulation parameters before they are actually applied to a real <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> tree.  
 <a href="classsparta_1_1ParameterTree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1ParameterTree_1_1Node.html" title="Node containing a Parameter and value to apply. Can be used to describes a value extracted from the t...">Node</a> containing a <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> and value to apply. Can be used to describes a value extracted from the tree when using get or tryGet. This is a copy of the value and is not in any way synchronized with the tree.  <a href="classsparta_1_1ParameterTree_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a86a4a2f703b6674ac351cbe76beadc7c"><td class="memItemLeft" align="right" valign="top"><a id="a86a4a2f703b6674ac351cbe76beadc7c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#a86a4a2f703b6674ac351cbe76beadc7c">ParameterTree</a> ()</td></tr>
<tr class="memdesc:a86a4a2f703b6674ac351cbe76beadc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor. <br /></td></tr>
<tr class="separator:a86a4a2f703b6674ac351cbe76beadc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd4f92803701ca79b27992b5c29f1eb"><td class="memItemLeft" align="right" valign="top"><a id="a7cd4f92803701ca79b27992b5c29f1eb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ParameterTree</b> (const <a class="el" href="classsparta_1_1ParameterTree.html">ParameterTree</a> &amp;rhp)</td></tr>
<tr class="separator:a7cd4f92803701ca79b27992b5c29f1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32815c98361e3a28e8676df5a6d86227"><td class="memItemLeft" align="right" valign="top"><a id="a32815c98361e3a28e8676df5a6d86227"></a>
<a class="el" href="classsparta_1_1ParameterTree.html">ParameterTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classsparta_1_1ParameterTree.html">ParameterTree</a> &amp;rhp)</td></tr>
<tr class="separator:a32815c98361e3a28e8676df5a6d86227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbe84e73b67cfa8e8ababe92f40f819"><td class="memItemLeft" align="right" valign="top"><a id="a6bbe84e73b67cfa8e8ababe92f40f819"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#a6bbe84e73b67cfa8e8ababe92f40f819">~ParameterTree</a> ()</td></tr>
<tr class="memdesc:a6bbe84e73b67cfa8e8ababe92f40f819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a6bbe84e73b67cfa8e8ababe92f40f819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a974464a4703971969a5b2744ecb23"><td class="memItemLeft" align="right" valign="top"><a id="aa3a974464a4703971969a5b2744ecb23"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#aa3a974464a4703971969a5b2744ecb23">clear</a> ()</td></tr>
<tr class="memdesc:aa3a974464a4703971969a5b2744ecb23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all content from this tree. <br /></td></tr>
<tr class="separator:aa3a974464a4703971969a5b2744ecb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182674f411ef8096b23d1963ff4b068e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#a182674f411ef8096b23d1963ff4b068e">set</a> (const std::string &amp;path, const std::string &amp;value, bool required, const std::string &amp;origin=&quot;&quot;)</td></tr>
<tr class="memdesc:a182674f411ef8096b23d1963ff4b068e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a parameter to the tree, replacing any existing parameter.  <a href="classsparta_1_1ParameterTree.html#a182674f411ef8096b23d1963ff4b068e">More...</a><br /></td></tr>
<tr class="separator:a182674f411ef8096b23d1963ff4b068e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45712ecf471d2dc630290ec0cc2d499c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#a45712ecf471d2dc630290ec0cc2d499c">create</a> (const std::string &amp;path, bool required=false)</td></tr>
<tr class="memdesc:a45712ecf471d2dc630290ec0cc2d499c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to the tree, with proper priority.  <a href="classsparta_1_1ParameterTree.html#a45712ecf471d2dc630290ec0cc2d499c">More...</a><br /></td></tr>
<tr class="separator:a45712ecf471d2dc630290ec0cc2d499c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9528e08541d80a408e8106d9d4f4905a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#a9528e08541d80a408e8106d9d4f4905a">get</a> (const std::string &amp;path) const</td></tr>
<tr class="memdesc:a9528e08541d80a408e8106d9d4f4905a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a node from the parameter tree while respecting parameter application order. In other words, getting through this method returns the latest value set for the parameter at the location described by <em>path</em>.  <a href="classsparta_1_1ParameterTree.html#a9528e08541d80a408e8106d9d4f4905a">More...</a><br /></td></tr>
<tr class="separator:a9528e08541d80a408e8106d9d4f4905a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f460d540785a00652cb637b7db6ad9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#ab8f460d540785a00652cb637b7db6ad9">operator[]</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ab8f460d540785a00652cb637b7db6ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a node form the parameter tree.  <a href="classsparta_1_1ParameterTree.html#ab8f460d540785a00652cb637b7db6ad9">More...</a><br /></td></tr>
<tr class="separator:ab8f460d540785a00652cb637b7db6ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8c6b1cef74b832eda5277d57d1fbbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#a4d8c6b1cef74b832eda5277d57d1fbbf">hasValue</a> (const std::string &amp;path, const bool must_be_leaf=true) const</td></tr>
<tr class="memdesc:a4d8c6b1cef74b832eda5277d57d1fbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to check if a node has value.  <a href="classsparta_1_1ParameterTree.html#a4d8c6b1cef74b832eda5277d57d1fbbf">More...</a><br /></td></tr>
<tr class="separator:a4d8c6b1cef74b832eda5277d57d1fbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be389fb5fdcad1e20bb9e484a031444"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#a3be389fb5fdcad1e20bb9e484a031444">exists</a> (const std::string &amp;path, const bool must_be_leaf=true) const</td></tr>
<tr class="memdesc:a3be389fb5fdcad1e20bb9e484a031444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to check if a node exists.  <a href="classsparta_1_1ParameterTree.html#a3be389fb5fdcad1e20bb9e484a031444">More...</a><br /></td></tr>
<tr class="separator:a3be389fb5fdcad1e20bb9e484a031444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05c3587e49f5a493189546859c56826"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#ab05c3587e49f5a493189546859c56826">getUnreadValueNodes</a> (std::vector&lt; const <a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a> * &gt; *nodes) const</td></tr>
<tr class="memdesc:ab05c3587e49f5a493189546859c56826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of values attached to the parameter tree which have values but have not been read. This is a smart system which looks at historical parameter values as well as the latest to be sure that all have been touched.  <a href="classsparta_1_1ParameterTree.html#ab05c3587e49f5a493189546859c56826">More...</a><br /></td></tr>
<tr class="separator:ab05c3587e49f5a493189546859c56826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a4bee5c29e6840fbd9debee26b7ff4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#a66a4bee5c29e6840fbd9debee26b7ff4">getUnreadValueNodes</a> (std::vector&lt; <a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a> * &gt; *nodes)</td></tr>
<tr class="memdesc:a66a4bee5c29e6840fbd9debee26b7ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of values attached to the parameter tree which have values but have not been read. This is a smart system which looks at historical parameter values as well as the latest to be sure that all have been touched. non-const version.  <a href="classsparta_1_1ParameterTree.html#a66a4bee5c29e6840fbd9debee26b7ff4">More...</a><br /></td></tr>
<tr class="separator:a66a4bee5c29e6840fbd9debee26b7ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500e65368ea5611eaf56991f5405e167"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#a500e65368ea5611eaf56991f5405e167">tryGet</a> (const std::string &amp;path, const bool must_be_leaf=true) const</td></tr>
<tr class="memdesc:a500e65368ea5611eaf56991f5405e167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get a node if it exists. Returns nullptr it it does not.  <a href="classsparta_1_1ParameterTree.html#a500e65368ea5611eaf56991f5405e167">More...</a><br /></td></tr>
<tr class="separator:a500e65368ea5611eaf56991f5405e167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59627a931ab951abfb9f23e1e130c83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#ae59627a931ab951abfb9f23e1e130c83">tryGet</a> (const std::string &amp;path, const bool must_be_leaf=true)</td></tr>
<tr class="memdesc:ae59627a931ab951abfb9f23e1e130c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">tryGet non-const version  <a href="classsparta_1_1ParameterTree.html#ae59627a931ab951abfb9f23e1e130c83">More...</a><br /></td></tr>
<tr class="separator:ae59627a931ab951abfb9f23e1e130c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd3fb12f3a74c97e6327f76f5d29147"><td class="memItemLeft" align="right" valign="top"><a id="a7cd3fb12f3a74c97e6327f76f5d29147"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#a7cd3fb12f3a74c97e6327f76f5d29147">isRequired</a> (const std::string &amp;path) const</td></tr>
<tr class="memdesc:a7cd3fb12f3a74c97e6327f76f5d29147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively find first leaf node matching this pattern and decide if any node matching that node's pattern is required to exist in the SPARTA tree. <br /></td></tr>
<tr class="separator:a7cd3fb12f3a74c97e6327f76f5d29147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481b54e97eb57da8c5615f0581f8e360"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#a481b54e97eb57da8c5615f0581f8e360">unrequire</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a481b54e97eb57da8c5615f0581f8e360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrequire a node in the tree.  <a href="classsparta_1_1ParameterTree.html#a481b54e97eb57da8c5615f0581f8e360">More...</a><br /></td></tr>
<tr class="separator:a481b54e97eb57da8c5615f0581f8e360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d7a0f75b13730fbb5955f823608c6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#ad1d7a0f75b13730fbb5955f823608c6b">isRead</a> (const std::string &amp;path) const</td></tr>
<tr class="memdesc:ad1d7a0f75b13730fbb5955f823608c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has a node with a given path been read.  <a href="classsparta_1_1ParameterTree.html#ad1d7a0f75b13730fbb5955f823608c6b">More...</a><br /></td></tr>
<tr class="separator:ad1d7a0f75b13730fbb5955f823608c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd830f2b405c0224e9e6ed31c61209e"><td class="memItemLeft" align="right" valign="top"><a id="accd830f2b405c0224e9e6ed31c61209e"></a>
<a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><b>getRoot</b> () const</td></tr>
<tr class="separator:accd830f2b405c0224e9e6ed31c61209e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2fe9b422143bb0e3b0cd693c05e3d5"><td class="memItemLeft" align="right" valign="top"><a id="a4f2fe9b422143bb0e3b0cd693c05e3d5"></a>
<a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRoot</b> ()</td></tr>
<tr class="separator:a4f2fe9b422143bb0e3b0cd693c05e3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fd5fe49149a462378ccb7fcc5c3650"><td class="memItemLeft" align="right" valign="top"><a id="ae0fd5fe49149a462378ccb7fcc5c3650"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#ae0fd5fe49149a462378ccb7fcc5c3650">merge</a> (const <a class="el" href="classsparta_1_1ParameterTree.html">ParameterTree</a> &amp;rhp)</td></tr>
<tr class="memdesc:ae0fd5fe49149a462378ccb7fcc5c3650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge this tree with another by applying all of its parameters to this tree. Parameters in the right tree will override this tree's parameters if there are duplicate paths or overlapping patterns. <br /></td></tr>
<tr class="separator:ae0fd5fe49149a462378ccb7fcc5c3650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5be5b764b87145f80bc81084c9cc0b"><td class="memItemLeft" align="right" valign="top"><a id="adb5be5b764b87145f80bc81084c9cc0b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html#adb5be5b764b87145f80bc81084c9cc0b">recursPrint</a> (std::ostream &amp;o) const</td></tr>
<tr class="memdesc:adb5be5b764b87145f80bc81084c9cc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively print. <br /></td></tr>
<tr class="separator:adb5be5b764b87145f80bc81084c9cc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Virtual <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> Tree. This represents a tree of parameters read from some source but does not necessarily correspond to the parameters in the simulation itself or even to the simulation tree. This is meant to provide a hierarchical view into simulation parameters before they are actually applied to a real <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> tree. </p>
<p>Eventually, this structure will automatically share data with <a class="el" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters.">sparta::ParameterSet</a> instances as they are created. For now, it is limited.</p>
<p>Typical use is to subclass this object for each simulator component/model which has a set of parameters it must consume. <a class="el" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters.">sparta::ParameterSet</a> provides a generic interface through which config-file parsers or command-line parsers can populate the parameters from strings. Models that expose the <a class="el" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters.">ParameterSet</a> full of <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">sparta::Parameter</a> instances should dynamic_cast a <a class="el" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters.">sparta::ParameterSet</a> supplied to them at runtime back to a known type and operate through Parameters directly instead of through this generic interface. </p>

<p class="definition">Definition at line <a class="el" href="ParameterTree_8hpp_source.html#l00037">37</a> of file <a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a45712ecf471d2dc630290ec0cc2d499c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45712ecf471d2dc630290ec0cc2d499c">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a>* sparta::ParameterTree::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a node to the tree, with proper priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to create. TEMPORARY: Must not contain parent references (i.e. extra dots) </td></tr>
    <tr><td class="paramname">Are</td><td>the nodes added by this call required to exist?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TEMPORARY: Returns a <a class="el" href="classsparta_1_1ParameterTree_1_1Node.html" title="Node containing a Parameter and value to apply. Can be used to describes a value extracted from the t...">Node</a> if one is created or found, nullptr if not. May return nullptr if parameter path contains parent reference (any '.' character whicih is proceded by another '.' or the beginnign of the string). This will be fixed eventually. Nothing else should cause this to return nullptr</dd></dl>
<p>Setting is fundamentally different than getting in a virtual parameter tree. It cannot fail and (when setting with patterns [paths containing wildcards]), new nodes are almost always created. </p>

<p class="definition">Definition at line <a class="el" href="ParameterTree_8hpp_source.html#l00855">855</a> of file <a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1ParameterTree_a45712ecf471d2dc630290ec0cc2d499c_cgraph.png" border="0" usemap="#aclasssparta_1_1ParameterTree_a45712ecf471d2dc630290ec0cc2d499c_cgraph" alt=""/></div>
<map name="classsparta_1_1ParameterTree_a45712ecf471d2dc630290ec0cc2d499c_cgraph" id="aclasssparta_1_1ParameterTree_a45712ecf471d2dc630290ec0cc2d499c_cgraph">
<area shape="rect" title="Add a node to the tree, with proper priority." alt="" coords="5,116,156,157"/>
<area shape="rect" href="classsparta_1_1ParameterTree_1_1Node.html#a1eaf182215a2d9f6b931b9f4e08b0392" title="Get a child for setting a parameter, creating it if needed." alt="" coords="204,116,355,157"/>
<area shape="rect" href="classsparta_1_1ParameterTree_1_1Node.html#ac27bf32902289e8992a279f14b79ea7a" title=" " alt="" coords="431,57,581,99"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1ef80729c2131ffb68b5e62b5002c321" title="Gets the next name between two &#39;.&#39; chars in a string starting at pos." alt="" coords="403,123,609,150"/>
<area shape="rect" href="classsparta_1_1ParameterTree_1_1Node.html#a4d2058de6b84a2ef756bfe0876d418a4" title="Attempts to get an immediate child with an exact match for a given name or pattern string...." alt="" coords="412,175,600,216"/>
<area shape="rect" href="classsparta_1_1ParameterTree_1_1Node.html#a8f53d8a81e030268ae3dc7da2b19c2d7" title="Does this node have a value written to it which can be accessed through:" alt="" coords="681,5,832,47"/>
<area shape="rect" href="classsparta_1_1ParameterTree_1_1Node.html#a5d7fac3aa3b32912136c83f8fdfcbab9" title="Not default&#45;constructable." alt="" coords="681,71,832,112"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a2cac07d5f406fa1300d0e283e2a1f498" title="Determines if a given node name has any wildcard characters which will be substituted in createSearch..." alt="" coords="657,161,856,203"/>
<area shape="rect" href="classsparta_1_1ParameterTree_1_1Node.html#a5b44b34a8091bc1b0b1e368c51a90b4b" title="Does a string, name, interpreted as a sparta TreeNode pattern, match another string interpreted as a ..." alt="" coords="681,227,832,268"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#aacb943215632699fbddc6554dacfbdf7" title="Compute a regex pattern for a node child path containing any number of wildcard characters (not a dot..." alt="" coords="904,227,1067,268"/>
</map>
</div>

</div>
</div>
<a id="a3be389fb5fdcad1e20bb9e484a031444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be389fb5fdcad1e20bb9e484a031444">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::ParameterTree::exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>must_be_leaf</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to check if a node exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path of the node to check </td></tr>
    <tr><td class="paramname">must_be_leaf</td><td>Check only if leaf node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="ParameterTree_8hpp_source.html#l00907">907</a> of file <a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>.</p>

</div>
</div>
<a id="a9528e08541d80a408e8106d9d4f4905a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9528e08541d80a408e8106d9d4f4905a">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a>&amp; sparta::ParameterTree::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a node from the parameter tree while respecting parameter application order. In other words, getting through this method returns the latest value set for the parameter at the location described by <em>path</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path of node to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if node with given path does not exist (see exists) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classsparta_1_1ParameterTree_1_1Node.html" title="Node containing a Parameter and value to apply. Can be used to describes a value extracted from the t...">Node</a> at the given location. This node is temporary and becomes stale on any modification to this <a class="el" href="classsparta_1_1ParameterTree.html" title="Virtual Parameter Tree. This represents a tree of parameters read from some source but does not neces...">ParameterTree</a>. Reading this node later may result in an incorrect value </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned node should be considered stale when this <a class="el" href="classsparta_1_1ParameterTree.html" title="Virtual Parameter Tree. This represents a tree of parameters read from some source but does not neces...">ParameterTree</a> is modified </dd></dl>

<p class="definition">Definition at line <a class="el" href="ParameterTree_8hpp_source.html#l00874">874</a> of file <a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1ParameterTree_a9528e08541d80a408e8106d9d4f4905a_cgraph.png" border="0" usemap="#aclasssparta_1_1ParameterTree_a9528e08541d80a408e8106d9d4f4905a_cgraph" alt=""/></div>
<map name="classsparta_1_1ParameterTree_a9528e08541d80a408e8106d9d4f4905a_cgraph" id="aclasssparta_1_1ParameterTree_a9528e08541d80a408e8106d9d4f4905a_cgraph">
<area shape="rect" title="Gets a node from the parameter tree while respecting parameter application order. In other words,..." alt="" coords="5,13,180,39"/>
<area shape="rect" href="classsparta_1_1ParameterTree.html#a500e65368ea5611eaf56991f5405e167" title="Try to get a node if it exists. Returns nullptr it it does not." alt="" coords="228,5,379,47"/>
</map>
</div>

</div>
</div>
<a id="ab05c3587e49f5a493189546859c56826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05c3587e49f5a493189546859c56826">&#9670;&nbsp;</a></span>getUnreadValueNodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::ParameterTree::getUnreadValueNodes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a> * &gt; *&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of values attached to the parameter tree which have values but have not been read. This is a smart system which looks at historical parameter values as well as the latest to be sure that all have been touched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">nodes</td><td>Nodes with unread values. This is not cleared</td></tr>
  </table>
  </dd>
</dl>
<p>The implementation of this method is highly coupled with the <a class="el" href="classsparta_1_1ParameterTree.html#a500e65368ea5611eaf56991f5405e167" title="Try to get a node if it exists. Returns nullptr it it does not.">tryGet()</a> which marks read parameters (including historically set parameters) as read to satify this method </p>

<p class="definition">Definition at line <a class="el" href="ParameterTree_8hpp_source.html#l00922">922</a> of file <a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>.</p>

</div>
</div>
<a id="a66a4bee5c29e6840fbd9debee26b7ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a4bee5c29e6840fbd9debee26b7ff4">&#9670;&nbsp;</a></span>getUnreadValueNodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::ParameterTree::getUnreadValueNodes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a> * &gt; *&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of values attached to the parameter tree which have values but have not been read. This is a smart system which looks at historical parameter values as well as the latest to be sure that all have been touched. non-const version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">nodes</td><td>Nodes with unread values. This is not cleared</td></tr>
  </table>
  </dd>
</dl>
<p>The implementation of this method is highly coupled with the <a class="el" href="classsparta_1_1ParameterTree.html#a500e65368ea5611eaf56991f5405e167" title="Try to get a node if it exists. Returns nullptr it it does not.">tryGet()</a> which marks read parameters (including historically set parameters) as read to satify this method </p>

<p class="definition">Definition at line <a class="el" href="ParameterTree_8hpp_source.html#l00937">937</a> of file <a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>.</p>

</div>
</div>
<a id="a4d8c6b1cef74b832eda5277d57d1fbbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8c6b1cef74b832eda5277d57d1fbbf">&#9670;&nbsp;</a></span>hasValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::ParameterTree::hasValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>must_be_leaf</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to check if a node has value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path of the node to check </td></tr>
    <tr><td class="paramname">must_be_leaf</td><td>Check only if leaf node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="ParameterTree_8hpp_source.html#l00896">896</a> of file <a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1ParameterTree_a4d8c6b1cef74b832eda5277d57d1fbbf_cgraph.png" border="0" usemap="#aclasssparta_1_1ParameterTree_a4d8c6b1cef74b832eda5277d57d1fbbf_cgraph" alt=""/></div>
<map name="classsparta_1_1ParameterTree_a4d8c6b1cef74b832eda5277d57d1fbbf_cgraph" id="aclasssparta_1_1ParameterTree_a4d8c6b1cef74b832eda5277d57d1fbbf_cgraph">
<area shape="rect" title="Try to check if a node has value." alt="" coords="5,5,156,47"/>
<area shape="rect" href="classsparta_1_1ParameterTree_1_1Node.html#a8f53d8a81e030268ae3dc7da2b19c2d7" title="Does this node have a value written to it which can be accessed through:" alt="" coords="204,5,355,47"/>
</map>
</div>

</div>
</div>
<a id="ad1d7a0f75b13730fbb5955f823608c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d7a0f75b13730fbb5955f823608c6b">&#9670;&nbsp;</a></span>isRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::ParameterTree::isRead </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has a node with a given path been read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to check</td></tr>
  </table>
  </dd>
</dl>
<p>Resolves a path to any matching nodes (which may include any number of wildcard nodes) and checks that at least one of those nodes have been read 1 or more times. </p>

<p class="definition">Definition at line <a class="el" href="ParameterTree_8hpp_source.html#l01011">1011</a> of file <a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1ParameterTree_ad1d7a0f75b13730fbb5955f823608c6b_cgraph.png" border="0" usemap="#aclasssparta_1_1ParameterTree_ad1d7a0f75b13730fbb5955f823608c6b_cgraph" alt=""/></div>
<map name="classsparta_1_1ParameterTree_ad1d7a0f75b13730fbb5955f823608c6b_cgraph" id="aclasssparta_1_1ParameterTree_ad1d7a0f75b13730fbb5955f823608c6b_cgraph">
<area shape="rect" title="Has a node with a given path been read." alt="" coords="5,5,156,47"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1ef80729c2131ffb68b5e62b5002c321" title="Gets the next name between two &#39;.&#39; chars in a string starting at pos." alt="" coords="204,13,411,39"/>
</map>
</div>

</div>
</div>
<a id="ab8f460d540785a00652cb637b7db6ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f460d540785a00652cb637b7db6ad9">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a>&amp; sparta::ParameterTree::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a node form the parameter tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of parameter to retrieve </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ParameterTree_8hpp_source.html#l00886">886</a> of file <a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1ParameterTree_ab8f460d540785a00652cb637b7db6ad9_cgraph.png" border="0" usemap="#aclasssparta_1_1ParameterTree_ab8f460d540785a00652cb637b7db6ad9_cgraph" alt=""/></div>
<map name="classsparta_1_1ParameterTree_ab8f460d540785a00652cb637b7db6ad9_cgraph" id="aclasssparta_1_1ParameterTree_ab8f460d540785a00652cb637b7db6ad9_cgraph">
<area shape="rect" title="Gets a node form the parameter tree." alt="" coords="5,5,156,47"/>
<area shape="rect" href="classsparta_1_1ParameterTree.html#a9528e08541d80a408e8106d9d4f4905a" title="Gets a node from the parameter tree while respecting parameter application order. In other words,..." alt="" coords="204,13,379,39"/>
<area shape="rect" href="classsparta_1_1ParameterTree.html#a500e65368ea5611eaf56991f5405e167" title="Try to get a node if it exists. Returns nullptr it it does not." alt="" coords="427,5,577,47"/>
</map>
</div>

</div>
</div>
<a id="a182674f411ef8096b23d1963ff4b068e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182674f411ef8096b23d1963ff4b068e">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::ParameterTree::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>origin</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a parameter to the tree, replacing any existing parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path (from root) to assign value </td></tr>
    <tr><td class="paramname">value</td><td>Value to assign to a path in this tree </td></tr>
    <tr><td class="paramname">required</td><td>Must this parameter exist? </td></tr>
    <tr><td class="paramname">origin</td><td>Origin of the value (e.g. "foo.yaml line:50 col:23") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TEMPORARY: Returns true of parameter is set, false if not. May return false if parameter path contains parent reference (any '.' character whicih is proceded by another '.' or the beginnign of the string). This will be fixed eventually.</dd></dl>
<p>Setting is fundamentally different than getting in a virtual parameter tree. It cannot fail and (when setting with patterns [paths containing wildcards]), new nodes are almost always created. </p>

<p class="definition">Definition at line <a class="el" href="ParameterTree_8hpp_source.html#l00831">831</a> of file <a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1ParameterTree_a182674f411ef8096b23d1963ff4b068e_cgraph.png" border="0" usemap="#aclasssparta_1_1ParameterTree_a182674f411ef8096b23d1963ff4b068e_cgraph" alt=""/></div>
<map name="classsparta_1_1ParameterTree_a182674f411ef8096b23d1963ff4b068e_cgraph" id="aclasssparta_1_1ParameterTree_a182674f411ef8096b23d1963ff4b068e_cgraph">
<area shape="rect" title="Add a parameter to the tree, replacing any existing parameter." alt="" coords="5,157,180,183"/>
<area shape="rect" href="classsparta_1_1ParameterTree.html#a45712ecf471d2dc630290ec0cc2d499c" title="Add a node to the tree, with proper priority." alt="" coords="228,116,379,157"/>
<area shape="rect" href="classsparta_1_1ParameterTree_1_1Node.html#ac5ee96d25a6a0bd7445c1f63c169bf23" title="Set a value on this node directly." alt="" coords="228,181,379,223"/>
<area shape="rect" href="classsparta_1_1ParameterTree_1_1Node.html#a1eaf182215a2d9f6b931b9f4e08b0392" title="Get a child for setting a parameter, creating it if needed." alt="" coords="427,116,577,157"/>
<area shape="rect" href="classsparta_1_1ParameterTree_1_1Node.html#ac27bf32902289e8992a279f14b79ea7a" title=" " alt="" coords="653,57,804,99"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1ef80729c2131ffb68b5e62b5002c321" title="Gets the next name between two &#39;.&#39; chars in a string starting at pos." alt="" coords="625,123,832,150"/>
<area shape="rect" href="classsparta_1_1ParameterTree_1_1Node.html#a4d2058de6b84a2ef756bfe0876d418a4" title="Attempts to get an immediate child with an exact match for a given name or pattern string...." alt="" coords="635,175,823,216"/>
<area shape="rect" href="classsparta_1_1ParameterTree_1_1Node.html#a8f53d8a81e030268ae3dc7da2b19c2d7" title="Does this node have a value written to it which can be accessed through:" alt="" coords="904,5,1055,47"/>
<area shape="rect" href="classsparta_1_1ParameterTree_1_1Node.html#a5d7fac3aa3b32912136c83f8fdfcbab9" title="Not default&#45;constructable." alt="" coords="904,71,1055,112"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a2cac07d5f406fa1300d0e283e2a1f498" title="Determines if a given node name has any wildcard characters which will be substituted in createSearch..." alt="" coords="880,161,1079,203"/>
<area shape="rect" href="classsparta_1_1ParameterTree_1_1Node.html#a5b44b34a8091bc1b0b1e368c51a90b4b" title="Does a string, name, interpreted as a sparta TreeNode pattern, match another string interpreted as a ..." alt="" coords="904,227,1055,268"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#aacb943215632699fbddc6554dacfbdf7" title="Compute a regex pattern for a node child path containing any number of wildcard characters (not a dot..." alt="" coords="1127,227,1289,268"/>
</map>
</div>

</div>
</div>
<a id="ae59627a931ab951abfb9f23e1e130c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59627a931ab951abfb9f23e1e130c83">&#9670;&nbsp;</a></span>tryGet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a>* sparta::ParameterTree::tryGet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>must_be_leaf</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tryGet non-const version </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path of the node to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node at the given path </dd></dl>

<p class="definition">Definition at line <a class="el" href="ParameterTree_8hpp_source.html#l00955">955</a> of file <a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>.</p>

</div>
</div>
<a id="a500e65368ea5611eaf56991f5405e167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500e65368ea5611eaf56991f5405e167">&#9670;&nbsp;</a></span>tryGet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">Node</a>* sparta::ParameterTree::tryGet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>must_be_leaf</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to get a node if it exists. Returns nullptr it it does not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path of the node to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node at the given path </dd></dl>

<p class="definition">Definition at line <a class="el" href="ParameterTree_8hpp_source.html#l00946">946</a> of file <a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>.</p>

</div>
</div>
<a id="a481b54e97eb57da8c5615f0581f8e360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481b54e97eb57da8c5615f0581f8e360">&#9670;&nbsp;</a></span>unrequire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::ParameterTree::unrequire </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unrequire a node in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to the node to unrequire (set ignore) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node was found and set; false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="ParameterTree_8hpp_source.html#l00994">994</a> of file <a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1ParameterTree_a481b54e97eb57da8c5615f0581f8e360_cgraph.png" border="0" usemap="#aclasssparta_1_1ParameterTree_a481b54e97eb57da8c5615f0581f8e360_cgraph" alt=""/></div>
<map name="classsparta_1_1ParameterTree_a481b54e97eb57da8c5615f0581f8e360_cgraph" id="aclasssparta_1_1ParameterTree_a481b54e97eb57da8c5615f0581f8e360_cgraph">
<area shape="rect" title="Unrequire a node in the tree." alt="" coords="5,5,156,47"/>
<area shape="rect" href="classsparta_1_1ParameterTree_1_1Node.html#aee54cbea1229f3020f074f209749a798" title="Clear the required count. This is necessary if a parameter is flagged as deprecated or removed in a c..." alt="" coords="204,5,355,47"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/sparta/sparta/simulation/<a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li><li class="navelem"><a class="el" href="classsparta_1_1ParameterTree.html">ParameterTree</a></li>
    <li class="footer">Generated on Fri Sep 25 2020 04:28:29 for The Sparta Modeling Framework by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
